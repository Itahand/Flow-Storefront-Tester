import{config as t}from"@onflow/config";import*as n from"@onflow/types";import*as r from"@onflow/fcl";import{config as e,send as o,getBlock as c,decode as i,getEventsAtBlockHeightRange as s}from"@onflow/fcl";import{ec as u}from"elliptic";import{SHA3 as a}from"sha3";const f={emulator:{FungibleToken:"0xee82856bf20e2aa6",FlowFees:"0xe5a8b7f23e8b548f",FlowStorageFees:"0xf8d6e0586b0a20c7",FlowToken:"0x0ae53cb6e3f42a79"},testnet:{FungibleToken:"0x9a0766d93b6608b7",NonFungibleToken:"0x631e88ae7f1d7c20",FlowClusterQC:"0x9eca2b38b18b5dfe",FlowDKG:"0x9eca2b38b18b5dfe",FlowEpoch:"0x9eca2b38b18b5dfe",FlowIDTableStaking:"0x9eca2b38b18b5dfe",FlowToken:"0x7e60df042a9c0868",LockedTokens:"0x95e019a17d0e23d7",StakingProxy:"0x7aad92e5a0715d21",FlowStakingCollection:"0x95e019a17d0e23d7",FUSD:"0xe223d8a629e49c68"},mainnet:{FungibleToken:"0xf233dcee88fe0abe",NonFungibleToken:"0x1d7e57aa55817448",FlowClusterQC:"0x8624b52f9ddcd04a",FlowDKG:"0x8624b52f9ddcd04a",FlowEpoch:"0x8624b52f9ddcd04a",FlowIDTableStaking:"0x8624b52f9ddcd04a",FlowFees:"0xf919ee77447b7497",FlowToken:"0x1654653399040a61",LockedTokens:"0x8d0e87b65159ae63",StakingProxy:"0x62430cf28c26d095",FlowStakingCollection:"0x8d0e87b65159ae63",FUSD:"0x3c5959b568896393"}},l={emulator:{},testnet:{},mainnet:{}},m=t=>{for(const n of Object.keys(l)){const r=t[n],{name:e}=t;l[n]={...l[n],..."object"==typeof t[n]?r:{[e]:r}}}},d={mainnet:"https://access-mainnet-beta.onflow.org",testnet:"https://access-testnet.onflow.org",emulator:"http://localhost:8080"},h=function(){try{return Promise.resolve(function(){try{return Promise.resolve(t().get("ix.env")).then(function(t){return t||"emulator"})}catch(t){return Promise.reject(t)}}()).then(function(t){return{...f[t]||f.emulator,...l[t]||l.emulator}})}catch(t){return Promise.reject(t)}},p=function(n="emulator",r={}){try{const e=n.toLowerCase();if(!f[e])throw new Error(`Provided value "${e}" is not supported. Try "emulator", "testnet" or "mainnet". Default: "emulator"`);const{port:o,endpoint:c,limit:i,extend:s}=r,u="emulator"===e&&o?`http://localhost:${o}`:d[e],a=c||u;return Promise.resolve(t().put("ix.env",e)).then(function(){function n(){return s&&m(s),Promise.resolve(t().put("accessNode.api",a)).then(function(){})}const r=function(){if(i)return Promise.resolve(t().put("ix.executionLimit",i)).then(function(){})}();return r&&r.then?r.then(n):n()})}catch(t){return Promise.reject(t)}},g=t=>t.split(/\s/).map(t=>t.replace(/\s/g,"")).filter(t=>t.length>0&&"import"!==t&&"from"!==t),P=(t,n)=>{const[r,e]=n;return t[r]=e,t},w=t=>t&&0!==t.length?t.split("\n").filter(t=>/^\s*import\s+\w*\s+from/.test(t)).map(g).reduce(P,{}):{},y=(t,n={})=>{const r=w(t),e=[];for(const t in r)!n[t]&&Object.prototype.hasOwnProperty.call(r,t)&&e.push(t);return e},x=(t=[],n="")=>{const r="Missing imports for contracts:";console.error(n?`${n} ${r}`:r,t)},v=(t,n,r="")=>{const e=y(t,n);e.length>0&&x(e,r)},b=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,k=(t,n,r=!0)=>t.replace(b,(t,e,o,c,i)=>{const s=r?o:i;return`${e}${o} from ${(n instanceof Function?n(s):n[s])||i}`}),F=["public","private","storage"],$=t=>{const[n]=t.split("");return n.toUpperCase()+t.slice(1)},S=t=>t.replace(/-/g,"_").split("_").map((t,n)=>n>0?$(t):t).join(""),E=(t,n,r)=>r?t.replace(n,"").split(r):t.replace(n,"").split(I(t)),I=t=>{switch(!0){case t.indexOf("//")>=0:return"//";case t.indexOf("/")>=0:return"/";case t.indexOf("\\")>=0:return"\\";default:return""}},T=t=>t.replace(/\s+/g," "),N="contract",C="transaction",A="script",B=t=>t.split(",").map(t=>t.replace(/\s*/g,"")).filter(t=>""!==t),D=t=>t.replace(/(\/\*[\s\S]*?\*\/)|(\/\/.*)/g,""),j=t=>{let n=!1,r="";for(let e=0;e<t.length;e++)'"'===t[e]&&(n&&"\\"!==t[e-1]?(n=!1,r+=t[e]):n=!0),n||(r+=t[e]);return r},L=(t,n)=>{const r=D(t),e=T(r.replace(/[\n\r]/g,""));if(e){const t=new RegExp(n,"g").exec(e);if(t)return""===t[1]?[]:B(t[1])}return[]},U=t=>L(t,"(?:prepare\\s*\\(\\s*)([^\\)]*)(?:\\))"),q=t=>L(t,"(?:fun\\s+main\\s*\\(\\s*)([^\\)]*)(?:\\))"),K=t=>L(t,"(?:transaction\\s*\\(\\s*)([^\\)]*)(?:\\))"),M=t=>R(t).contractName,R=t=>{const n=D(t).replace(/(resource|struct)\s+\w+\s*{[\s\S]+?}/g,""),r=/(?:access\(\w+\)|pub)\s+contract\s+(?:interface)*\s*(\w*)(\s*{[.\s\S]*init\s*\((.*?)\)[.\s\S]*})?/g.exec(n);if(!r||r.length<2)throw new Error("Contract Error: can't find name of the contract");return{contractName:r[1],args:r[3]||""}},_=t=>{const n=j(D(t));if(/transaction\s*(\(\s*\))*\s*/g.test(n)){const t=U(n),r=K(n);return{type:"transaction",signers:t.length,args:r}}if(/pub\s+fun\s+main\s*/g.test(n))return{type:"script",args:q(n)};if(/\w+\s+contract\s+(\w*\s*)\w*/g.test(n)){const{contractName:t,args:r}=R(n);return{type:"contract",signers:1,args:r,contractName:t}}return{type:"unknown"}},G=t=>t.match(/\/{3}\s*pragma\s*(.*)/g).reduce((t,n)=>{const r=n.match(/\/{3}\s*pragma\s+(\w*)\s+(.*)/),[,e,o]=r;return t[e]=o,t},{}),O=t=>!t||"string"!=typeof t,H=t=>!O(t)&&(t.startsWith("Int")||t.startsWith("UInt")||t.startsWith("Word")),Q=t=>"Path"===t||"Path?"===t||"PublicPath"===t||"PublicPath?"===t||"PrivatePath"===t||"PrivatePath?"===t||"StoragePath"===t||"StoragePath?"===t||"CapabilityPath"===t||"CapabilityPath?"===t,z=t=>{if(O(t))return!1;const n=t.replace(/\s/g,"");return n.startsWith("[")&&n.endsWith("]")},W=t=>{if(O(t))return!1;const n=t.replace(/\s/g,"");return n.startsWith("{")&&n.endsWith("}")},J=t=>z(t)||W(t)||Q(t);function V(t,n,r){if(!t.s){if(r instanceof X){if(!r.s)return void(r.o=V.bind(null,t,n));1&n&&(n=r.s),r=r.v}if(r&&r.then)return void r.then(V.bind(null,t,n),V.bind(null,t,2));t.s=n,t.v=r;const e=t.o;e&&e(t)}}const X=function(){function t(){}return t.prototype.then=function(n,r){const e=new t,o=this.s;if(o){const t=1&o?n:r;if(t){try{V(e,1,t(this.v))}catch(t){V(e,2,t)}return e}return this}return this.o=function(t){try{const o=t.v;1&t.s?V(e,1,n?n(o):o):r?V(e,1,r(o)):V(e,2,o)}catch(t){V(e,2,t)}},e},t}(),Y={ARGUMENT:"argument"},Z=function(t){try{const{type:n}=t;return Promise.resolve(e().get("ix.plugins")).then(function(r){const o=r||{},c=o[n]||[];return Promise.resolve(e().put("ix.plugins",{...o,[n]:[...c,t]})).then(function(){})})}catch(t){return Promise.reject(t)}},tt=function(t){try{return Promise.resolve(e().get("ix.plugins")).then(function(n){const r=(n||{})[t];return!!(r&&r.length>0)&&r})}catch(t){return Promise.reject(t)}};function nt(t,n,r){if(!t.s){if(r instanceof rt){if(!r.s)return void(r.o=nt.bind(null,t,n));1&n&&(n=r.s),r=r.v}if(r&&r.then)return void r.then(nt.bind(null,t,n),nt.bind(null,t,2));t.s=n,t.v=r;const e=t.o;e&&e(t)}}const rt=function(){function t(){}return t.prototype.then=function(n,r){const e=new t,o=this.s;if(o){const t=1&o?n:r;if(t){try{nt(e,1,t(this.v))}catch(t){nt(e,2,t)}return e}return this}return this.o=function(t){try{const o=t.v;1&t.s?nt(e,1,n?n(o):o):r?nt(e,1,r(o)):nt(e,2,o)}catch(t){nt(e,2,t)}},e},t}(),et=t=>t.split(/(\w+)\s*:\s*([\w{}[\]:\s?]*)/).filter(t=>""!==t).map(t=>t.replace(/\s*/g,"")),ot=t=>et(t)[1],ct=t=>/{(.*)}/.exec(t)[1].split(/([^:]*):(.*)/).map(t=>t.replace(/\s/g,"")).filter(t=>t),it=t=>/\[(.*)\]/.exec(t)[1].replace(/\s+/g,""),st=(t,n,r="")=>{if(n>t){const e=`Incorrect number of arguments: found ${t} of ${n}`;console.error(r?`${r} ${e}`:e)}},ut=(t="items",n,r,e="")=>{if(r!==n){const o=`Incorrect number of ${t}: found ${n} of ${r}`;console.error(e?`${e} ${o}`:o)}},at=t=>!O(t)&&(t.includes("?")?n.Optional(n[(t=>t.slice(0,-1))(t)]):n[t]),ft=t=>{if(J(t))switch(!0){case z(t):{const r=it(t);return n.Array(ft(r))}case W(t):{const[r,e]=ct(t),o={key:ft(r),value:ft(e)};return n.Dictionary(o)}case Q(t):return n.Path;default:return at(t)}return at(t)},lt=function(t,n){try{return Promise.resolve(tt(Y.ARGUMENT)).then(function(e){function o(){let t;const n=ft(i);switch(!0){case(t=>{if(O(t))return!1;let n=t.endsWith("?")?t.slice(0,-1):t;return H(n)||(t=>"String"===t)(n)||(t=>"Character"===t)(n)||(t=>"Bool"===t)(n)})(i):return r.arg(c,n);case(t=>!O(t)&&(t.startsWith("Fix64")||t.startsWith("UFix64")))(i):return null===c?r.arg(null,n):(isNaN(parseFloat(c))&&(t=>{throw new Error("Type Error: Expected proper value for fixed type")})(),r.arg(parseFloat(c).toFixed(8),n));case(t=>"Address"===t||"Address?"===t)(i):{const t=null==(m=c)?null:"0x"+(t=>null==t?null:t.replace(/^0x/,""))(m);return r.arg(t,n)}case Q(i):return r.arg((t=>{if(t.startsWith("/")){const n=t.slice(1).split("/");if(2!==n.length)throw Error("Incorrect Path - identifier missing");if(!F.includes(n[0]))throw Error("Incorrect Path - wrong domain");const[r,e]=n;return{domain:r,identifier:e}}throw Error("Incorrect Path - shall start with `/`")})(c),n);case z(i):{function e(e){return t?e:r.arg(c,n)}const o=it(i),s=function(){if(J(o))return Promise.resolve(Promise.all(c.map(function(t){try{return Promise.resolve(lt(o,t)).then(function({value:t}){return t})}catch(t){return Promise.reject(t)}}))).then(function(e){return t=1,r.arg(e,n)})}();return s&&s.then?s.then(e):e(s)}case W(i):{function o(){return r.arg(m,n)}const[t,e]=ct(i),m=[],d=Object.keys(c),h=(s=d,u=function(n){function r(){const n=H(t)?parseInt(o):o;m.push({key:n,value:i})}const o=d[n];let i;const s=function(){if(J(e))return Promise.resolve(lt(e,c[o])).then(function(t){i=t.value});i=c[o]}();return s&&s.then?s.then(r):r()},l=-1,function t(n){try{for(;++l<s.length;)if((n=u(l))&&n.then){if(!((r=n)instanceof rt&&1&r.s))return void n.then(t,f||(f=nt.bind(null,a=new rt,2)));n=n.v}a?nt(a,1,n):a=n}catch(t){nt(a||(a=new rt),2,t)}var r}(),a);return h&&h.then?h.then(o):o()}default:throw`${i} is not supported`}var s,u,a,f,l,m}let c=n,i=t;const s=function(){if(e)return Promise.resolve(function(t,n){try{function r(){return{type:u,value:a}}let u=t.type,a=t.value;const f=(e=n,o=function(t){const{resolver:r}=n[t];return Promise.resolve(r(u,a)).then(function(t){u=t.type,a=t.value})},s=-1,function t(n){try{for(;++s<e.length;)if((n=o(s))&&n.then){if(!((r=n)instanceof X&&1&r.s))return void n.then(t,i||(i=V.bind(null,c=new X,2)));n=n.v}c?V(c,1,n):c=n}catch(t){V(c||(c=new X),2,t)}var r}(),c);return Promise.resolve(f&&f.then?f.then(r):r())}catch(t){return Promise.reject(t)}var e,o,c,i,s}({type:t,value:n},e)).then(function(t){c=t.value,i=t.type})}();return s&&s.then?s.then(o):o()})}catch(t){return Promise.reject(t)}},mt=function(t=[],n){try{if(t.length>n.length)throw new Error("Not enough arguments");return Promise.all(n.map(function(n,r){try{return Promise.resolve(lt(t[r],n)).then(function(t){var n;return(n=t).xform.asArgument(n.value),t})}catch(t){return Promise.reject(t)}}))}catch(t){return Promise.reject(t)}},dt=function(t,n=[]){try{const r=_(t).args.map(ot);return mt(r,n)}catch(t){return Promise.reject(t)}},ht=function(t,n){try{if(0===t.length)return Promise.resolve([]);const e=t[0];return Array.isArray(e)&&e.length>0&&e[e.length-1].asArgument?Promise.resolve((t=>t.reduce((t,n)=>[...t,...((t,n)=>{const e=t[t.length-1];return t.slice(0,-1).map(t=>((t,n)=>r.arg(t,n))(t,e))})(n)],[]))(t)):dt(n,t)}catch(t){return Promise.reject(t)}},pt=23830813,gt=16,Pt=t=>null==t?null:t.replace(/^0x/,""),wt=function(){try{return Promise.resolve(o([c(!0)]).then(i))}catch(t){return Promise.reject(t)}},yt=function(){try{return Promise.resolve(wt()).then(function(t){return t.height})}catch(t){return Promise.reject(t)}},xt=t=>{const{address:n,contractName:r,eventName:e}=t;return`A.${Pt(n)}.${r}.${e}`},vt=function(t,n){try{function r(){return c<pt&&(console.warn(`"to" value of range is lower than current spork root. setting to ${pt}`),c=pt),e<pt&&(console.warn(`"from" value of range is lower than current spork root. setting to ${pt}`),e=pt),o([s(xt(t),e,c)]).then(i)}if(!t.address)throw"contract shall have address field";if(!t.contractName)throw"contract shall have contractName field";if(!t.eventName)throw"contract shall have event name";let e,c;const u=function(){if(n){function t(){n.from||(e=c-249)}c=n.to,e=n.from;const r=function(){if(!n.to)return Promise.resolve(yt()).then(function(t){c=t})}();return r&&r.then?r.then(t):t()}return Promise.resolve(yt()).then(function(t){c=t,e=c-249,e<pt&&(console.warn(`"from" value of range is lower than current spork root. setting to ${pt}`),e=pt)})}();return Promise.resolve(u&&u.then?u.then(r):r())}catch(t){return Promise.reject(t)}},bt=function(t,n={}){try{function r(n){let r=n-e;return n<s&&(console.warn(`"to" value of range is lower than current spork root. setting to ${pt}`),n=s),r<s&&(console.warn(`"from" value of range is lower than current spork root. setting to ${pt}`),r=s),new Promise((c,s)=>{const a=function(){try{const f=function(s,f){try{var l=(console.log(`${r} -> ${n}...`),Promise.resolve(vt(t,{from:r,to:n})).then(function(t){0!==t.length?(clearInterval(void 0),c({events:t})):(u>i&&c({events:t,latestBlock:n}),n=r,r-=e,u+=e,setTimeout(a,o))}))}catch(t){return f(t)}return l&&l.then?l.then(void 0,f):l}(0,function(t){s({events:[],err:t,latestBlock:n})});return Promise.resolve(f&&f.then?f.then(function(){}):void 0)}catch(t){return Promise.reject(t)}};setTimeout(a,o)})}const{step:e=200,delay:o=500,start:c=null,maxRange:i=Infinity,sporkLimit:s=pt}=n;let u=e;return Promise.resolve(c?r(c):Promise.resolve(yt()).then(r))}catch(t){return Promise.reject(t)}},kt=new u("p256"),Ft=(t,n)=>{const r=kt.keyFromPrivate(Buffer.from(t,"hex")).sign((t=>{const n=new a(256);return n.update(Buffer.from(t,"hex")),n.digest()})(n)),e=r.r.toArrayLike(Buffer,"be",32),o=r.s.toArrayLike(Buffer,"be",32);return Buffer.concat([e,o]).toString("hex")},$t=t=>{if("object"==typeof t){if(void 0===t.privateKey)throw Error("privateKey is required");if(void 0===t.address)throw Error("address is required");void 0===t.keyId&&console.warning(`key index have incorrect format. found '${typeof t.keyId}', required 'num'`);const{address:n,privateKey:e,keyId:o=0}=t;return((t,n,e=0)=>function(o={}){try{t=Pt(t);const c=function(r){try{return Promise.resolve({keyId:e,addr:(o=t,null==o?null:"0x"+Pt(o)),signature:Ft(n,r.message)})}catch(t){return Promise.reject(t)}var o};return Promise.resolve({...o,tempId:`${t}-${e}`,addr:r.sansPrefix(t),keyId:e,signingFunction:c})}catch(t){return Promise.reject(t)}})(n,e,o)}return t};function St(t,n){try{var r=t()}catch(t){return n(t)}return r&&r.then?r.then(void 0,n):r}const Et=function(n,e){try{const{code:o,cadence:c,args:i,addressMap:s,limit:u,processed:a}=n,f=o||c;return Promise.resolve(h()).then(function(o){function c(){return Promise.resolve(t().get("ix.executionLimit")).then(function(t){if(d.push(r.limit(u||t||100)),"transaction"===e){const{proposer:t,payer:e,signers:o=[]}=n,c=0===o.length?[e]:o,i=t||e;d.push(r.payer($t(e))),d.push(r.proposer($t(i))),d.push(r.authorizations(c.map($t)))}return r.send(d)})}const l={...o,...s},m=a?f:k(f,l),d="script"===e?[r.script(m)]:[r.transaction(m)],h=function(){if(i)return Promise.resolve(ht(i,f)).then(function(t){d.push(r.args(t))})}();return h&&h.then?h.then(c):c()})}catch(t){return Promise.reject(t)}},It=function(t){const{raw:n=!1}=t;return Promise.resolve(St(function(){return Promise.resolve(Et(t,"script")).then(function(t){return n?[t.encodedData,null]:Promise.resolve(r.decode(t)).then(function(t){return[t,null]})})},function(t){return[null,t]}))},Tt=function(t){const{wait:n="seal"}=t;return Promise.resolve(St(function(){return Promise.resolve(Et(t,"transaction")).then(function(t){let e;function o(n){return e?n:[t.transactionId,null]}const c=function(){if(n){const o=(t=>{if("string"==typeof t){const n=t.toLowerCase();if(n.includes("final"))return"onceFinalized";if(n.includes("exec"))return"onceExecuted";if(n.includes("seal"))return"onceSealed"}return console.log(`⚠️ [33mStatus value [1m[35m"${t}"[33m[2m is not supported. Reverting to [32m"onceSealed"[0m`),"onceSealed"})(n);return Promise.resolve(r.tx(t)[o]()).then(function(n){const r={txId:t,...n};return e=1,[r,null]})}}();return c&&c.then?c.then(o):o(c)})},function(t){return[null,t]}))},Nt=function(t){try{const{name:n,to:r,payer:e,proposer:o,code:c,update:i=!1,processed:s=!1,addressMap:u={}}=t,a=s?c:k(c,u),f=i?"\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  ":"\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n",l=Buffer.from(a,"utf8").toString("hex");let m=r,d=r;return e&&(d=e,m=o||e),Tt({payer:d,proposer:m,signers:[r],code:f,args:[n,l]})}catch(t){return Promise.reject(t)}},Ct=function(t){try{return Nt({...t,update:!0})}catch(t){return Promise.reject(t)}};export{N as CONTRACT,gt as CURRENT_SPORK_NUMBER,pt as CURRENT_SPORK_ROOT,Y as PLUGIN_TYPES,A as SCRIPT,C as TRANSACTION,ot as argType,$ as capitalizeFirstLetter,T as collapseSpaces,Nt as deployContract,It as executeScript,m as extendEnvironment,L as extract,M as extractContractName,R as extractContractParameters,w as extractImports,q as extractScriptArguments,U as extractSigners,K as extractTransactionArguments,bt as findLatestEvents,B as generateSchema,it as getArrayType,yt as getChainHeight,ct as getDictionaryTypes,h as getEnvironment,xt as getEventName,vt as getEventsInRange,wt as getLatestBlock,tt as getPlugins,G as getPragmaNotes,I as getSplitCharacter,_ as getTemplateInfo,lt as mapArgument,mt as mapArguments,dt as mapValuesToCode,y as missingImports,Tt as mutate,It as query,Z as registerPlugin,k as replaceImportAddresses,x as report,st as reportArguments,ut as reportMissing,v as reportMissingImports,ht as resolveArguments,Tt as sendTransaction,p as setEnvironment,et as splitArgs,D as stripComments,j as stripStrings,E as trimAndSplit,S as underscoreToCamelCase,Ct as updateContract};
//# sourceMappingURL=main.module.js.map

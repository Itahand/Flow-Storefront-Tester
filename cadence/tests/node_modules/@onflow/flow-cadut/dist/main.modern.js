import{config as t}from"@onflow/config";import*as e from"@onflow/types";import*as n from"@onflow/fcl";import{config as r,send as o,getBlock as a,decode as s,getEventsAtBlockHeightRange as c}from"@onflow/fcl";import{ec as i}from"elliptic";import{SHA3 as u}from"sha3";function l(){return(l=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}).apply(this,arguments)}const d={emulator:{FungibleToken:"0xee82856bf20e2aa6",FlowFees:"0xe5a8b7f23e8b548f",FlowStorageFees:"0xf8d6e0586b0a20c7",FlowToken:"0x0ae53cb6e3f42a79"},testnet:{FungibleToken:"0x9a0766d93b6608b7",NonFungibleToken:"0x631e88ae7f1d7c20",FlowClusterQC:"0x9eca2b38b18b5dfe",FlowDKG:"0x9eca2b38b18b5dfe",FlowEpoch:"0x9eca2b38b18b5dfe",FlowIDTableStaking:"0x9eca2b38b18b5dfe",FlowToken:"0x7e60df042a9c0868",LockedTokens:"0x95e019a17d0e23d7",StakingProxy:"0x7aad92e5a0715d21",FlowStakingCollection:"0x95e019a17d0e23d7",FUSD:"0xe223d8a629e49c68"},mainnet:{FungibleToken:"0xf233dcee88fe0abe",NonFungibleToken:"0x1d7e57aa55817448",FlowClusterQC:"0x8624b52f9ddcd04a",FlowDKG:"0x8624b52f9ddcd04a",FlowEpoch:"0x8624b52f9ddcd04a",FlowIDTableStaking:"0x8624b52f9ddcd04a",FlowFees:"0xf919ee77447b7497",FlowToken:"0x1654653399040a61",LockedTokens:"0x8d0e87b65159ae63",StakingProxy:"0x62430cf28c26d095",FlowStakingCollection:"0x8d0e87b65159ae63",FUSD:"0x3c5959b568896393"}},f={emulator:{},testnet:{},mainnet:{}},p=t=>{for(const e of Object.keys(f)){const n=t[e],{name:r}=t;f[e]=l({},f[e],"object"==typeof t[e]?n:{[r]:n})}},w={mainnet:"https://access-mainnet-beta.onflow.org",testnet:"https://access-testnet.onflow.org",emulator:"http://localhost:8080"},m=async()=>{const e=await(async()=>await t().get("ix.env")||"emulator")();return l({},d[e]||d.emulator,f[e]||f.emulator)},g=async(e="emulator",n={})=>{const r=e.toLowerCase();if(!d[r])throw new Error(`Provided value "${r}" is not supported. Try "emulator", "testnet" or "mainnet". Default: "emulator"`);const{port:o,endpoint:a,limit:s,extend:c}=n,i=a||("emulator"===r&&o?`http://localhost:${o}`:w[r]);await t().put("ix.env",r),s&&await t().put("ix.executionLimit",s),c&&p(c),await t().put("accessNode.api",i)},h=t=>t.split(/\s/).map(t=>t.replace(/\s/g,"")).filter(t=>t.length>0&&"import"!==t&&"from"!==t),y=(t,e)=>{const[n,r]=e;return t[n]=r,t},x=t=>t&&0!==t.length?t.split("\n").filter(t=>/^\s*import\s+\w*\s+from/.test(t)).map(h).reduce(y,{}):{},b=(t,e={})=>{const n=x(t),r=[];for(const t in n)!e[t]&&Object.prototype.hasOwnProperty.call(n,t)&&r.push(t);return r},v=(t=[],e="")=>{const n="Missing imports for contracts:";console.error(e?`${e} ${n}`:n,t)},k=(t,e,n="")=>{const r=b(t,e);r.length>0&&v(r,n)},F=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,$=(t,e,n=!0)=>t.replace(F,(t,r,o,a,s)=>{const c=n?o:s;return`${r}${o} from ${(e instanceof Function?e(c):e[c])||s}`}),S=["public","private","storage"],P=t=>{const[e]=t.split("");return e.toUpperCase()+t.slice(1)},E=t=>t.replace(/-/g,"_").split("_").map((t,e)=>e>0?P(t):t).join(""),I=(t,e,n)=>n?t.replace(e,"").split(n):t.replace(e,"").split(T(t)),T=t=>{switch(!0){case t.indexOf("//")>=0:return"//";case t.indexOf("/")>=0:return"/";case t.indexOf("\\")>=0:return"\\";default:return""}},N=t=>t.replace(/\s+/g," "),C="contract",A="transaction",B="script",j=t=>t.split(",").map(t=>t.replace(/\s*/g,"")).filter(t=>""!==t),D=t=>t.replace(/(\/\*[\s\S]*?\*\/)|(\/\/.*)/g,""),L=t=>{let e=!1,n="";for(let r=0;r<t.length;r++)'"'===t[r]&&(e&&"\\"!==t[r-1]?(e=!1,n+=t[r]):e=!0),e||(n+=t[r]);return n},O=(t,e)=>{const n=D(t),r=N(n.replace(/[\n\r]/g,""));if(r){const t=new RegExp(e,"g").exec(r);if(t)return""===t[1]?[]:j(t[1])}return[]},U=t=>O(t,"(?:prepare\\s*\\(\\s*)([^\\)]*)(?:\\))"),q=t=>O(t,"(?:fun\\s+main\\s*\\(\\s*)([^\\)]*)(?:\\))"),K=t=>O(t,"(?:transaction\\s*\\(\\s*)([^\\)]*)(?:\\))"),M=t=>R(t).contractName,R=t=>{const e=D(t).replace(/(resource|struct)\s+\w+\s*{[\s\S]+?}/g,""),n=/(?:access\(\w+\)|pub)\s+contract\s+(?:interface)*\s*(\w*)(\s*{[.\s\S]*init\s*\((.*?)\)[.\s\S]*})?/g.exec(e);if(!n||n.length<2)throw new Error("Contract Error: can't find name of the contract");return{contractName:n[1],args:n[3]||""}},_=t=>{const e=L(D(t));if(/transaction\s*(\(\s*\))*\s*/g.test(e)){const t=U(e),n=K(e);return{type:"transaction",signers:t.length,args:n}}if(/pub\s+fun\s+main\s*/g.test(e))return{type:"script",args:q(e)};if(/\w+\s+contract\s+(\w*\s*)\w*/g.test(e)){const{contractName:t,args:n}=R(e);return{type:"contract",signers:1,args:n,contractName:t}}return{type:"unknown"}},G=t=>t.match(/\/{3}\s*pragma\s*(.*)/g).reduce((t,e)=>{const n=e.match(/\/{3}\s*pragma\s+(\w*)\s+(.*)/),[,r,o]=n;return t[r]=o,t},{}),H=t=>!t||"string"!=typeof t,Q=t=>!H(t)&&(t.startsWith("Int")||t.startsWith("UInt")||t.startsWith("Word")),z=t=>"Path"===t||"Path?"===t||"PublicPath"===t||"PublicPath?"===t||"PrivatePath"===t||"PrivatePath?"===t||"StoragePath"===t||"StoragePath?"===t||"CapabilityPath"===t||"CapabilityPath?"===t,W=t=>{if(H(t))return!1;const e=t.replace(/\s/g,"");return e.startsWith("[")&&e.endsWith("]")},J=t=>{if(H(t))return!1;const e=t.replace(/\s/g,"");return e.startsWith("{")&&e.endsWith("}")},V=t=>W(t)||J(t)||z(t),X={ARGUMENT:"argument"},Y=async t=>{const{type:e}=t,n=await r().get("ix.plugins")||{},o=n[e]||[];await r().put("ix.plugins",l({},n,{[e]:[...o,t]}))},Z=async t=>{const e=(await r().get("ix.plugins")||{})[t];return!!(e&&e.length>0)&&e},tt=t=>t.split(/(\w+)\s*:\s*([\w{}[\]:\s?]*)/).filter(t=>""!==t).map(t=>t.replace(/\s*/g,"")),et=t=>tt(t)[1],nt=t=>/{(.*)}/.exec(t)[1].split(/([^:]*):(.*)/).map(t=>t.replace(/\s/g,"")).filter(t=>t),rt=t=>/\[(.*)\]/.exec(t)[1].replace(/\s+/g,""),ot=(t,e,n="")=>{if(e>t){const r=`Incorrect number of arguments: found ${t} of ${e}`;console.error(n?`${n} ${r}`:r)}},at=(t="items",e,n,r="")=>{if(n!==e){const o=`Incorrect number of ${t}: found ${e} of ${n}`;console.error(r?`${r} ${o}`:o)}},st=t=>!H(t)&&(t.includes("?")?e.Optional(e[(t=>t.slice(0,-1))(t)]):e[t]),ct=t=>{if(V(t))switch(!0){case W(t):{const n=rt(t);return e.Array(ct(n))}case J(t):{const[n,r]=nt(t),o={key:ct(n),value:ct(r)};return e.Dictionary(o)}case z(t):return e.Path;default:return st(t)}return st(t)},it=async(t,e)=>{const r=await Z(X.ARGUMENT);let o=e,a=t;if(r){let n=await(async(t,e)=>{let n=t.type,r=t.value;for(let t=0;t<e.length;t++){const{resolver:o}=e[t],a=await o(n,r);n=a.type,r=a.value}return{type:n,value:r}})({type:t,value:e},r);o=n.value,a=n.type}const s=ct(a);switch(!0){case(t=>{if(H(t))return!1;let e=t.endsWith("?")?t.slice(0,-1):t;return Q(e)||(t=>"String"===t)(e)||(t=>"Character"===t)(e)||(t=>"Bool"===t)(e)})(a):return n.arg(o,s);case(t=>!H(t)&&(t.startsWith("Fix64")||t.startsWith("UFix64")))(a):return null===o?n.arg(null,s):(isNaN(parseFloat(o))&&(t=>{throw new Error("Type Error: Expected proper value for fixed type")})(),n.arg(parseFloat(o).toFixed(8),s));case(t=>"Address"===t||"Address?"===t)(a):{const t=null==(c=o)?null:"0x"+(t=>null==t?null:t.replace(/^0x/,""))(c);return n.arg(t,s)}case z(a):return n.arg((t=>{if(t.startsWith("/")){const e=t.slice(1).split("/");if(2!==e.length)throw Error("Incorrect Path - identifier missing");if(!S.includes(e[0]))throw Error("Incorrect Path - wrong domain");const[n,r]=e;return{domain:n,identifier:r}}throw Error("Incorrect Path - shall start with `/`")})(o),s);case W(a):{const t=rt(a);if(V(t)){const e=await Promise.all(o.map(async e=>{const{value:n}=await it(t,e);return n}));return n.arg(e,s)}return n.arg(o,s)}case J(a):{const[t,e]=nt(a),r=[],c=Object.keys(o);for(let n=0;n<c.length;n++){const a=c[n];let s;s=V(e)?(await it(e,o[a])).value:o[a];const i=Q(t)?parseInt(a):a;r.push({key:i,value:s})}return n.arg(r,s)}default:throw`${a} is not supported`}var c},ut=async(t=[],e)=>{if(t.length>e.length)throw new Error("Not enough arguments");return Promise.all(e.map(async(e,n)=>{const r=await it(t[n],e);var o;return(o=r).xform.asArgument(o.value),r}))},lt=async(t,e=[])=>{const n=_(t).args.map(et);return ut(n,e)},dt=async(t,e)=>{if(0===t.length)return[];const r=t[0];return Array.isArray(r)&&r.length>0&&r[r.length-1].asArgument?(t=>t.reduce((t,e)=>[...t,...((t,e)=>{const r=t[t.length-1];return t.slice(0,-1).map(t=>((t,e)=>n.arg(t,e))(t,r))})(e)],[]))(t):lt(e,t)},ft=23830813,pt=16,wt=t=>null==t?null:t.replace(/^0x/,""),mt=async()=>o([a(!0)]).then(s),gt=async()=>(await mt()).height,ht=t=>{const{address:e,contractName:n,eventName:r}=t;return`A.${wt(e)}.${n}.${r}`},yt=async(t,e)=>{if(!t.address)throw"contract shall have address field";if(!t.contractName)throw"contract shall have contractName field";if(!t.eventName)throw"contract shall have event name";let n,r;return e?(r=e.to,n=e.from,e.to||(r=await gt()),e.from||(n=r-249)):(r=await gt(),n=r-249,n<ft&&(console.warn(`"from" value of range is lower than current spork root. setting to ${ft}`),n=ft)),r<ft&&(console.warn(`"to" value of range is lower than current spork root. setting to ${ft}`),r=ft),n<ft&&(console.warn(`"from" value of range is lower than current spork root. setting to ${ft}`),n=ft),o([c(ht(t),n,r)]).then(s)},xt=async(t,e={})=>{const{step:n=200,delay:r=500,start:o=null,maxRange:a=Infinity,sporkLimit:s=ft}=e;let c=n,i=o||await gt(),u=i-n;return i<s&&(console.warn(`"to" value of range is lower than current spork root. setting to ${ft}`),i=s),u<s&&(console.warn(`"from" value of range is lower than current spork root. setting to ${ft}`),u=s),new Promise((e,o)=>{setTimeout(async function s(){try{console.log(`${u} -> ${i}...`);const o=await yt(t,{from:u,to:i});0!==o.length?(clearInterval(void 0),e({events:o})):(c>a&&e({events:o,latestBlock:i}),i=u,u-=n,c+=n,setTimeout(s,r))}catch(t){o({events:[],err:t,latestBlock:i})}},r)})},bt=new i("p256"),vt=(t,e)=>{const n=bt.keyFromPrivate(Buffer.from(t,"hex")).sign((t=>{const e=new u(256);return e.update(Buffer.from(t,"hex")),e.digest()})(e)),r=n.r.toArrayLike(Buffer,"be",32),o=n.s.toArrayLike(Buffer,"be",32);return Buffer.concat([r,o]).toString("hex")},kt=t=>{if("object"==typeof t){if(void 0===t.privateKey)throw Error("privateKey is required");if(void 0===t.address)throw Error("address is required");void 0===t.keyId&&console.warning(`key index have incorrect format. found '${typeof t.keyId}', required 'num'`);const{address:e,privateKey:r,keyId:o=0}=t;return((t,e,r=0)=>async(o={})=>l({},o,{tempId:`${t=wt(t)}-${r}`,addr:n.sansPrefix(t),keyId:r,signingFunction:async n=>{return{keyId:r,addr:(o=t,null==o?null:"0x"+wt(o)),signature:vt(e,n.message)};var o}}))(e,r,o)}return t},Ft=async(e,r)=>{const{code:o,cadence:a,args:s,addressMap:c,limit:i,processed:u}=e,d=o||a,f=l({},await m(),c),p=u?d:$(d,f),w="script"===r?[n.script(p)]:[n.transaction(p)];if(s){const t=await dt(s,d);w.push(n.args(t))}const g=await t().get("ix.executionLimit");if(w.push(n.limit(i||g||100)),"transaction"===r){const{proposer:t,payer:r,signers:o=[]}=e,a=0===o.length?[r]:o,s=t||r;w.push(n.payer(kt(r))),w.push(n.proposer(kt(s))),w.push(n.authorizations(a.map(kt)))}return n.send(w)},$t=async t=>{const{raw:e=!1}=t;try{const r=await Ft(t,"script");return e?[r.encodedData,null]:[await n.decode(r),null]}catch(t){return[null,t]}},St=async t=>{const{wait:e="seal"}=t;try{const r=await Ft(t,"transaction");if(e){const t=(t=>{if("string"==typeof t){const e=t.toLowerCase();if(e.includes("final"))return"onceFinalized";if(e.includes("exec"))return"onceExecuted";if(e.includes("seal"))return"onceSealed"}return console.log(`âš ï¸ [33mStatus value [1m[35m"${t}"[33m[2m is not supported. Reverting to [32m"onceSealed"[0m`),"onceSealed"})(e);return[l({txId:r},await n.tx(r)[t]()),null]}return[r.transactionId,null]}catch(t){return[null,t]}},Pt=async t=>{const{name:e,to:n,payer:r,proposer:o,code:a,update:s=!1,processed:c=!1,addressMap:i={}}=t,u=c?a:$(a,i),l=s?"\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  ":"\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n",d=Buffer.from(u,"utf8").toString("hex");let f=n,p=n;return r&&(p=r,f=o||r),St({payer:p,proposer:f,signers:[n],code:l,args:[e,d]})},Et=async t=>Pt(l({},t,{update:!0}));export{C as CONTRACT,pt as CURRENT_SPORK_NUMBER,ft as CURRENT_SPORK_ROOT,X as PLUGIN_TYPES,B as SCRIPT,A as TRANSACTION,et as argType,P as capitalizeFirstLetter,N as collapseSpaces,Pt as deployContract,$t as executeScript,p as extendEnvironment,O as extract,M as extractContractName,R as extractContractParameters,x as extractImports,q as extractScriptArguments,U as extractSigners,K as extractTransactionArguments,xt as findLatestEvents,j as generateSchema,rt as getArrayType,gt as getChainHeight,nt as getDictionaryTypes,m as getEnvironment,ht as getEventName,yt as getEventsInRange,mt as getLatestBlock,Z as getPlugins,G as getPragmaNotes,T as getSplitCharacter,_ as getTemplateInfo,it as mapArgument,ut as mapArguments,lt as mapValuesToCode,b as missingImports,St as mutate,$t as query,Y as registerPlugin,$ as replaceImportAddresses,v as report,ot as reportArguments,at as reportMissing,k as reportMissingImports,dt as resolveArguments,St as sendTransaction,g as setEnvironment,tt as splitArgs,D as stripComments,L as stripStrings,I as trimAndSplit,E as underscoreToCamelCase,Et as updateContract};
//# sourceMappingURL=main.modern.js.map

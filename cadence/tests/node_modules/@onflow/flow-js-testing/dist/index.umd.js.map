{"version":3,"file":"index.umd.js","sources":["../src/config.js","../src/address.js","../src/crypto.js","../src/utils.js","../src/interaction.js","../src/generated/transactions/createAccount.js","../src/generated/transactions/deployContract.js","../src/generated/transactions/initManager.js","../src/generated/transactions/mintTokens.js","../src/generated/transactions/registerContract.js","../src/generated/transactions/scratch.js","../src/generated/transactions/setBlockOffset.js","../src/generated/transactions/setTimestampOffset.js","../src/generated/transactions/updateContract.js","../src/generated/transactions/index.js","../src/deploy-code.js","../src/generated/contracts/FlowManager.js","../src/generated/scripts/checkManager.js","../src/generated/scripts/getAccountAddress.js","../src/generated/scripts/getBalance.js","../src/generated/scripts/getBlockOffset.js","../src/generated/scripts/getContractAddress.js","../src/generated/scripts/getTimestampOffset.js","../src/generated/index.js","../src/manager.js","../src/contract.js","../src/imports.js","../src/file.js","../src/templates.js","../src/jest-asserts.js","../src/emulator.js","../src/transformers.js","../src/account.js","../src/flow-token.js","../src/init.js"],"sourcesContent":["/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {flowConfig} from \"@onflow/fcl-config\"\nimport {config} from \"@onflow/config\"\n\n/**\n * Get value from provided scope and path.\n * @param scope - scope value.\n * @param path - value path in config (flow.json) file.\n * @param fallback - fallback value.\n * @returns {*} - value at specified scope and path.\n */\nexport const get = (scope, path, fallback) => {\n  if (typeof path === \"string\") return get(scope, path.split(\"/\"), fallback)\n  if (!path.length) return scope\n  try {\n    const [head, ...rest] = path\n    return get(scope[head], rest, fallback)\n  } catch (_error) {\n    return fallback\n  }\n}\n\n/**\n * Set globally available config value.\n * @param {string} key - key to be used to access stored value.\n * @param {string} env - value key in the environment (for example .env file).\n * @param {string} conf - value path in config (flow.json) file.\n * @param fallback - fallback value to be used if env and conf are absent.\n */\nexport const set = (key, env, conf, fallback) => {\n  let value = get(flowConfig(), conf, fallback)\n  if (!value) {\n    value = fallback\n  }\n  config().put(key, value)\n}\n\n/**\n * Returns config value at specified key.\n * @param key - key to the value.\n * @returns {Promise<*>} - value at specified key.\n */\nexport const getConfigValue = async key => {\n  return config().get(key)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const sansPrefix = address => {\n  if (address == null) return null\n  return address.replace(/^0x/, \"\")\n}\n\nexport const withPrefix = address => {\n  if (address == null) return null\n  return \"0x\" + sansPrefix(address)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ec as EC} from \"elliptic\"\nimport {SHA3} from \"sha3\"\nimport * as fcl from \"@onflow/fcl\"\nimport * as rlp from \"rlp\"\nimport {config} from \"@onflow/config\"\nimport {sansPrefix, withPrefix} from \"./address\"\nconst ec = new EC(\"p256\")\n\nconst hashMsgHex = msgHex => {\n  const sha = new SHA3(256)\n  sha.update(Buffer.from(msgHex, \"hex\"))\n  return sha.digest()\n}\n\nexport const signWithKey = (privateKey, msgHex) => {\n  const key = ec.keyFromPrivate(Buffer.from(privateKey, \"hex\"))\n  const sig = key.sign(hashMsgHex(msgHex))\n  const n = 32 // half of signature length?\n  const r = sig.r.toArrayLike(Buffer, \"be\", n)\n  const s = sig.s.toArrayLike(Buffer, \"be\", n)\n  return Buffer.concat([r, s]).toString(\"hex\")\n}\n\nexport const authorization =\n  (addr, keyId = 0) =>\n  async (account = {}) => {\n    const serviceAddress = await config().get(\"SERVICE_ADDRESS\")\n    const pkey = await config().get(\"PRIVATE_KEY\")\n\n    addr = sansPrefix(addr || serviceAddress)\n\n    const signingFunction = async data => ({\n      keyId,\n      addr: withPrefix(addr),\n      signature: signWithKey(pkey, data.message),\n    })\n\n    return {\n      ...account,\n      tempId: `${addr}-${keyId}`,\n      addr: fcl.sansPrefix(addr),\n      keyId,\n      signingFunction,\n    }\n  }\n\nexport const pubFlowKey = async () => {\n  const keys = ec.keyFromPrivate(\n    Buffer.from(await config().get(\"PRIVATE_KEY\"), \"hex\")\n  )\n  const publicKey = keys.getPublic(\"hex\").replace(/^04/, \"\")\n  return rlp\n    .encode([\n      Buffer.from(publicKey, \"hex\"), // publicKey hex to binary\n      2, // P256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      3, // SHA3-256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      1000, // give key full weight\n    ])\n    .toString(\"hex\")\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {createServer} from \"net\"\n\nexport const isObject = arg => typeof arg === \"object\" && arg !== null\n\nexport function getAvailablePorts(count = 1) {\n  if (count === 0) return Promise.resolve([])\n  return new Promise((resolve, reject) => {\n    const server = createServer()\n    server.listen(0, () => {\n      const port = server.address().port\n      server.close(async err => {\n        if (err) reject(err)\n        resolve([...(await getAvailablePorts(count - 1)), port])\n      })\n    })\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fcl from \"@onflow/fcl\"\nimport {resolveArguments} from \"@onflow/flow-cadut\"\nimport {authorization} from \"./crypto\"\nimport {getTransactionCode, getScriptCode, defaultsByName} from \"./file\"\nimport {resolveImports, replaceImportAddresses} from \"./imports\"\nimport {getServiceAddress} from \"./manager\"\nimport {isObject} from \"./utils\"\n\nconst DEFAULT_LIMIT = 999\n\nexport const extractParameters = ixType => {\n  return async params => {\n    let ixCode, ixName, ixSigners, ixArgs, ixService, ixTransformers, ixLimit\n\n    if (isObject(params[0])) {\n      const [props] = params\n      const {\n        name,\n        code,\n        args,\n        signers,\n        transformers,\n        limit,\n        service = false,\n      } = props\n\n      ixService = service\n\n      if (!name && !code) {\n        throw Error(\n          \"Both `name` and `code` are missing. Provide either of them\"\n        )\n      }\n      ixName = name\n      ixCode = code\n\n      ixSigners = signers\n      ixArgs = args\n      ixTransformers = transformers || []\n      ixLimit = limit\n    } else {\n      if (ixType === \"script\") {\n        ;[ixName, ixArgs, ixLimit, ixTransformers] = params\n      } else {\n        ;[ixName, ixSigners, ixArgs, ixLimit, ixTransformers] = params\n      }\n    }\n\n    // Check that limit is always set\n    ixLimit = ixLimit || DEFAULT_LIMIT\n\n    if (ixName) {\n      const getIxTemplate =\n        ixType === \"script\" ? getScriptCode : getTransactionCode\n      ixCode = await getIxTemplate({name: ixName})\n    }\n\n    // We need a way around to allow initial scripts and transactions for Manager contract\n    let deployedContracts\n    if (ixService) {\n      deployedContracts = defaultsByName\n    } else {\n      deployedContracts = await resolveImports(ixCode)\n    }\n\n    const serviceAddress = await getServiceAddress()\n    const addressMap = {\n      ...defaultsByName,\n      ...deployedContracts,\n      FlowManager: serviceAddress,\n    }\n\n    ixCode = replaceImportAddresses(ixCode, addressMap)\n\n    // Apply all the necessary transformations to the code\n    for (const i in ixTransformers) {\n      const transformer = ixTransformers[i]\n      ixCode = await transformer(ixCode)\n    }\n\n    return {\n      code: ixCode,\n      signers: ixSigners,\n      args: ixArgs,\n      limit: ixLimit,\n    }\n  }\n}\n\n/**\n * Submits transaction to emulator network and waits before it will be sealed.\n * Returns transaction result.\n * @param {string} [props.name] - Name of Cadence template file\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {string} [props.code] - Cadence code of the transaction.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @param {[string]} [props.signers] - list of signers, who will authorize transaction, specified as array of addresses.\n * @returns {Promise<any>}\n */\n\nexport const sendTransaction = async (...props) => {\n  try {\n    const extractor = extractParameters(\"tx\")\n    const {code, args, signers, limit} = await extractor(props)\n\n    const serviceAuth = authorization()\n\n    // set repeating transaction code\n    const ix = [\n      fcl.transaction(code),\n      fcl.payer(serviceAuth),\n      fcl.proposer(serviceAuth),\n      fcl.limit(limit),\n    ]\n\n    // use signers if specified\n    if (signers) {\n      const auths = signers.map(address => authorization(address))\n      ix.push(fcl.authorizations(auths))\n    } else {\n      // and only service account if no signers\n      ix.push(fcl.authorizations([serviceAuth]))\n    }\n\n    // add arguments if any\n    if (args) {\n      const resolvedArgs = await resolveArguments(args, code)\n      ix.push(fcl.args(resolvedArgs))\n    }\n    const response = await fcl.send(ix)\n    const result = await fcl.tx(response).onceExecuted()\n\n    return [result, null]\n  } catch (e) {\n    return [null, e]\n  }\n}\n\n/**\n * Sends script code for execution. Returns decoded value\n * @param {string} props.code - Cadence code of the script to be submitted.\n * @param {string} props.name - name of the file to source code from.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @returns {Promise<*>}\n */\n\nexport const executeScript = async (...props) => {\n  try {\n    const extractor = extractParameters(\"script\")\n    const {code, args, limit} = await extractor(props)\n\n    const ix = [fcl.script(code), fcl.limit(limit)]\n    // add arguments if any\n    if (args) {\n      const resolvedArgs = await resolveArguments(args, code)\n      ix.push(fcl.args(resolvedArgs))\n    }\n    const response = await fcl.send(ix)\n    const result = await fcl.decode(response)\n    return [result, null]\n  } catch (e) {\n    return [null, e]\n  }\n}\n","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction (_ name: String, pubKey: String, manager: Address) {\r\n    prepare( admin: AuthAccount) {\r\n        let newAccount = AuthAccount(payer:admin)\r\n        newAccount.addPublicKey(pubKey.decodeHex())\r\n\r\n        let linkPath = FlowManager.accountManagerPath\r\n        let accountManager = getAccount(manager)\r\n                            .getCapability(linkPath)!\r\n                            .borrow<&FlowManager.Mapper>()!\r\n        \r\n        // Create a record in account database\r\n        let address = newAccount.address\r\n        accountManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for createAccount transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const createAccountTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `createAccount =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends createAccount transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const createAccount = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await createAccountTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `createAccount =>`);\n  reportMissing(\"signers\", signers.length, 1, `createAccount =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\r\n    prepare(acct: AuthAccount){\r\n        let decoded = code.decodeHex()\r\n        acct.contracts.add(\r\n           name: name,\r\n           code: decoded,\r\n           ##ARGS-LIST##\r\n        )\r\n\r\n        let linkPath = FlowManager.contractManagerPath\r\n        let contractManager = getAccount(manager)\r\n                    .getCapability(linkPath)!\r\n                    .borrow<&FlowManager.Mapper>()!\r\n\r\n        let address = acct.address\r\n        contractManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for deployContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const deployContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `deployContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends deployContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const deployContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await deployContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `deployContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `deployContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\ntransaction ( code: String ) {\r\n    prepare( admin: AuthAccount) {\r\n        admin.contracts.add(\r\n           name: \"FlowManager\",\r\n           code: code.decodeHex(),\r\n        )\r\n   }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for initManager transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const initManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `initManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends initManager transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const initManager = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await initManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `initManager =>`);\n  reportMissing(\"signers\", signers.length, 1, `initManager =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for mintTokens transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const mintTokensTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `mintTokens =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends mintTokens transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const mintTokens = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await mintTokensTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `mintTokens =>`);\n  reportMissing(\"signers\", signers.length, 1, `mintTokens =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction(name: String, address: Address) {\r\n    prepare(signer: AuthAccount){\r\n        let linkPath = FlowManager.contractManagerPath\r\n        let contractManager = signer\r\n                                .getCapability(linkPath)!\r\n                                .borrow<&FlowManager.Mapper>()!\r\n        contractManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for registerContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const registerContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `registerContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends registerContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const registerContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await registerContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `registerContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `registerContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\ntransaction{\r\n    prepare(acct: AuthAccount){\r\n        log(acct.address)\r\n    }\r\n}\n`;\n\n/**\n* Method to generate cadence code for scratch transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const scratchTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `scratch =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends scratch transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const scratch = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await scratchTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `scratch =>`);\n  reportMissing(\"signers\", signers.length, 1, `scratch =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(offset: UInt64){\n    prepare(signer:AuthAccount){\n        FlowManager.setBlockOffset(offset)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for setBlockOffset transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const setBlockOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `setBlockOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends setBlockOffset transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const setBlockOffset = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await setBlockOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `setBlockOffset =>`);\n  reportMissing(\"signers\", signers.length, 1, `setBlockOffset =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(offset: UFix64){\n    prepare(signer:AuthAccount){\n        FlowManager.setTimestampOffset(offset)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for setTimestampOffset transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const setTimestampOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `setTimestampOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends setTimestampOffset transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const setTimestampOffset = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await setTimestampOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `setTimestampOffset =>`);\n  reportMissing(\"signers\", signers.length, 1, `setTimestampOffset =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for updateContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const updateContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `updateContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends updateContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const updateContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await updateContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `updateContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `updateContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","import { createAccountTemplate, createAccount } from \"./createAccount\";\nimport { deployContractTemplate, deployContract } from \"./deployContract\";\nimport { initManagerTemplate, initManager } from \"./initManager\";\nimport { mintTokensTemplate, mintTokens } from \"./mintTokens\";\nimport { registerContractTemplate, registerContract } from \"./registerContract\";\nimport { scratchTemplate, scratch } from \"./scratch\";\nimport { setBlockOffsetTemplate, setBlockOffset } from \"./setBlockOffset\";\nimport { setTimestampOffsetTemplate, setTimestampOffset } from \"./setTimestampOffset\";\nimport { updateContractTemplate, updateContract } from \"./updateContract\";\n\nexport default {\n  createAccountTemplate,\n  createAccount,\n  deployContractTemplate,\n  deployContract,\n  initManagerTemplate,\n  initManager,\n  mintTokensTemplate,\n  mintTokens,\n  registerContractTemplate,\n  registerContract,\n  scratchTemplate,\n  scratch,\n  setBlockOffsetTemplate,\n  setBlockOffset,\n  setTimestampOffsetTemplate,\n  setTimestampOffset,\n  updateContractTemplate,\n  updateContract,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {sendTransaction} from \"./interaction\"\nimport {getServiceAddress} from \"./manager\"\nimport {defaultsByName, getContractCode} from \"./file\"\n\nimport txRegistry from \"./generated/transactions\"\nimport {isObject} from \"./utils\"\nimport {\n  extractContractParameters,\n  generateSchema,\n  splitArgs,\n} from \"@onflow/flow-cadut\"\nimport {replaceImportAddresses, resolveImports} from \"./imports\"\n\nconst {updateContractTemplate, deployContractTemplate} = txRegistry\n\nexport const hexContract = contract =>\n  Buffer.from(contract, \"utf8\").toString(\"hex\")\n\nconst extractParameters = async params => {\n  let ixName, ixTo, ixAddressMap, ixArgs, ixUpdate\n\n  if (isObject(params[0])) {\n    const [props] = params\n    const {name, to, addressMap, args, update} = props\n\n    if (!name) {\n      throw Error(\"'name' field is missing\")\n    }\n\n    ixName = name\n    ixTo = to\n    ixArgs = args\n    ixAddressMap = addressMap\n    ixUpdate = update\n  } else {\n    ;[ixName, ixTo, ixAddressMap, ixArgs, ixUpdate] = params\n  }\n\n  const serviceAddress = await getServiceAddress()\n  const addressMap = {\n    ...defaultsByName,\n    FlowManager: serviceAddress,\n    ...ixAddressMap,\n  }\n\n  return {\n    name: ixName,\n    to: ixTo,\n    args: ixArgs,\n    update: ixUpdate,\n    addressMap,\n  }\n}\n\n/**\n * Deploys a contract by name to specified account\n * Returns transaction result.\n * @param {string} props.to - If no address is supplied, the contract will be deployed to the emulator service account.\n * @param {string} props.name  - The name of the contract to look for. This should match a .cdc file located at the specified `basePath`.\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced.\n * @returns {Promise<any>}\n */\nexport const deployContractByName = async (...props) => {\n  const params = await extractParameters(props)\n  const {to, name, addressMap, args, update = false} = params\n\n  const resolvedAddress = to || (await getServiceAddress())\n  const contractCode = await getContractCode({name, addressMap})\n\n  const ixName = /[\\\\/]/.test(name) ? null : name\n\n  return deployContract({\n    to: resolvedAddress,\n    code: contractCode,\n    name: ixName,\n    args,\n    update,\n  })\n}\n\n/**\n * Deploys contract as Cadence code to specified account\n * Returns transaction result.\n * @param {string} props.code - Cadence code for contract to be deployed\n * @param {string} props.to - If no address is supplied, the contract\n * will be deployed to the emulator service account\n * @param {string} props.name  - The name of the contract to look for. This should match\n * a .cdc file located at the specified `basePath`\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced\n */\nexport const deployContract = async props => {\n  const {to, code: contractCode, name, args, update} = props\n\n  const params = await extractContractParameters(contractCode)\n  const ixName = name || params.contractName\n\n  // TODO: extract name from contract code\n  const containerAddress = to || (await getServiceAddress())\n  const managerAddress = await getServiceAddress()\n\n  // Replace import addresses, before hexing contract code\n  const deployedContracts = await resolveImports(contractCode)\n  const serviceAddress = await getServiceAddress()\n  const addressMap = {\n    ...defaultsByName,\n    ...deployedContracts,\n    FlowManager: serviceAddress,\n  }\n\n  const hexedCode = hexContract(\n    replaceImportAddresses(contractCode, addressMap)\n  )\n\n  let code = update\n    ? await updateContractTemplate(addressMap)\n    : await deployContractTemplate(addressMap)\n\n  let deployArgs = [ixName, hexedCode, managerAddress]\n\n  if (args) {\n    deployArgs = deployArgs.concat(args)\n    const schema = generateSchema(params.args).map(item => splitArgs(item)[0])\n\n    const argLetter = \"abcdefghijklmnopqrstuvwxyz\"\n    let argList = []\n    for (let i = 0; i < schema.length; i++) {\n      const value = schema[i]\n      argList.push(`${argLetter[i]}: ${value}`)\n    }\n\n    code = code.replace(\"##ARGS-WITH-TYPES##\", `, ${params.args}`)\n    code = code.replace(\"##ARGS-LIST##\", argList)\n  } else {\n    code = code.replace(\"##ARGS-WITH-TYPES##\", ``)\n    code = code.replace(\"##ARGS-LIST##\", \"\")\n  }\n\n  const signers = [containerAddress]\n\n  return sendTransaction({\n    code,\n    args: deployArgs,\n    signers,\n  })\n}\n","/** pragma type contract **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  deployContract,\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\npub contract FlowManager {\r\n\r\n    /// Account Manager\r\n    pub event AccountAdded(address: Address)\r\n\r\n    pub struct Mapper {\r\n        pub let accounts: {String: Address}\r\n\r\n        pub fun getAddress(_ name: String): Address? {\r\n            return self.accounts[name]\r\n        }\r\n\r\n        pub fun setAddress(_ name: String, address: Address){\r\n            self.accounts[name] = address\r\n            emit FlowManager.AccountAdded(address: address)\r\n        }\r\n\r\n        init(){\r\n            self.accounts = {}\r\n        }\r\n    }\r\n\r\n    pub fun getAccountAddress(_ name: String): Address?{\r\n        let accountManager = self.account\r\n            .getCapability(self.accountManagerPath)\r\n            .borrow<&FlowManager.Mapper>()!\r\n\r\n        return accountManager.getAddress(name)\r\n    }\r\n\r\n    pub let defaultAccounts: {Address : String}\r\n\r\n    pub fun resolveDefaultAccounts(_ address: Address): Address{\r\n        let alias = self.defaultAccounts[address]!\r\n        return self.getAccountAddress(alias)!\r\n    }\r\n\r\n    pub let accountManagerStorage: StoragePath\r\n    pub let contractManagerStorage: StoragePath\r\n    pub let accountManagerPath: PublicPath\r\n    pub let contractManagerPath: PublicPath\r\n\r\n    /// Environment Manager\r\n    pub event BlockOffsetChanged(offset: UInt64)\r\n    pub event TimestampOffsetChanged(offset: UFix64)\r\n\r\n    pub struct MockBlock {\r\n        pub let id: [UInt8; 32]\r\n        pub let height: UInt64\r\n        pub let view: UInt64\r\n        pub let timestamp: UFix64\r\n\r\n        init(_ id: [UInt8; 32], _ height: UInt64, _ view: UInt64, _ timestamp: UFix64){\r\n            self.id = id\r\n            self.height = height\r\n            self.view = view\r\n            self.timestamp = timestamp\r\n        }\r\n    }\r\n\r\n    pub fun setBlockOffset(_ offset: UInt64){\r\n        self.blockOffset = offset\r\n        emit FlowManager.BlockOffsetChanged(offset: offset)\r\n    }\r\n\r\n    pub fun setTimestampOffset(_ offset: UFix64){\r\n        self.timestampOffset = offset\r\n        emit FlowManager.TimestampOffsetChanged(offset: offset)\r\n    }\r\n\r\n    pub fun getBlockHeight(): UInt64 {\r\n        var block = getCurrentBlock()\r\n        return block.height + self.blockOffset\r\n    }\r\n\r\n    pub fun getBlockTimestamp(): UFix64 {\r\n        var block = getCurrentBlock()\r\n        return block.timestamp + self.timestampOffset\r\n    }\r\n\r\n    pub fun getBlock(): MockBlock {\r\n        var block =  getCurrentBlock()\r\n        let mockBlock = MockBlock(block.id, block.height, block.view, block.timestamp);\r\n        return mockBlock\r\n    }\r\n\r\n    pub var blockOffset: UInt64;\r\n    pub var timestampOffset: UFix64;\r\n\r\n\r\n    // Initialize contract\r\n    init(){\r\n        // Environment defaults\r\n        self.blockOffset = 0;\r\n        self.timestampOffset = 0.0;\r\n\r\n        // Account Manager initialization\r\n        let accountManager = Mapper()\r\n        let contractManager = Mapper()\r\n\r\n        self.defaultAccounts = {\r\n          0x01: \"Alice\",\r\n          0x02: \"Bob\",\r\n          0x03: \"Charlie\",\r\n          0x04: \"Dave\",\r\n          0x05: \"Eve\"\r\n        }\r\n\r\n        self.accountManagerStorage = /storage/testSuiteAccountManager\r\n        self.contractManagerStorage = /storage/testSuiteContractManager\r\n\r\n        self.accountManagerPath = /public/testSuiteAccountManager\r\n        self.contractManagerPath = /public/testSuiteContractManager\r\n        \r\n        // Destroy previously stored values\r\n        self.account.load<Mapper>(from: self.accountManagerStorage)\r\n        self.account.load<Mapper>(from: self.contractManagerStorage)\r\n\r\n        self.account.save(accountManager, to: self.accountManagerStorage)\r\n        self.account.save(contractManager, to: self.contractManagerStorage)\r\n\r\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\r\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\r\n    }\r\n}\r\n \n`;\n\n/**\n* Method to generate cadence code for FlowManager contract\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const FlowManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `FlowManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Deploys FlowManager transaction to the network\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> args - list of arguments\n* param Array<string> - list of signers\n*/\nexport const  deployFlowManager = async (props) => {\n  const { addressMap = {} } = props;\n  const code = await FlowManagerTemplate(addressMap);\n  const name = \"FlowManager\"\n\n  return deployContract({ code, name, processed: true, ...props })\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty, cause script will throw error if FlowManager is not\n    // added to service address\n}\n\n`;\n\n/**\n* Method to generate cadence code for checkManager script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const checkManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `checkManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const checkManager = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await checkManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `checkManager =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\npub fun main(name: String, managerAccount: Address):Address? {\r\n    let manager = getAccount(managerAccount)\r\n    let linkPath = FlowManager.accountManagerPath\r\n    let accountManager = manager\r\n                        .getCapability(linkPath)\r\n                        .borrow<&FlowManager.Mapper>()!\r\n\r\n    return accountManager.getAddress(name)\r\n\r\n}\n`;\n\n/**\n* Method to generate cadence code for getAccountAddress script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getAccountAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getAccountAddress =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getAccountAddress = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getAccountAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `getAccountAddress =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\n// This script reads the balance field of an account's FlowToken Balance\r\n\r\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\r\nimport ExampleToken from 0xTOKENADDRESS\r\n\r\npub fun main(account: Address): UFix64 {\r\n    let acct = getAccount(account)\r\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\r\n        ?? panic(\"Could not borrow Balance reference to the Vault\")\r\n\r\n    return vaultRef.balance\r\n}\n`;\n\n/**\n* Method to generate cadence code for getBalance script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getBalanceTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBalance =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBalance = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getBalanceTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `getBalance =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main():UInt64 {\n    return FlowManager.blockOffset\n}\n\n`;\n\n/**\n* Method to generate cadence code for getBlockOffset script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getBlockOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBlockOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBlockOffset = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getBlockOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `getBlockOffset =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\npub fun main(name: String, managerAccount: Address):Address? {\r\n    let manager = getAccount(managerAccount)\r\n    let linkPath = FlowManager.contractManagerPath\r\n    let contractManager = manager\r\n                        .getCapability(linkPath)\r\n                        .borrow<&FlowManager.Mapper>()!\r\n\r\n    return contractManager.getAddress(name)\r\n\r\n}\n`;\n\n/**\n* Method to generate cadence code for getContractAddress script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getContractAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getContractAddress =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getContractAddress = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getContractAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `getContractAddress =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main():UFix64 {\n    return FlowManager.timestampOffset\n}\n\n`;\n\n/**\n* Method to generate cadence code for getTimestampOffset script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getTimestampOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getTimestampOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getTimestampOffset = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getTimestampOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `getTimestampOffset =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","import contracts from \"./contracts\";\nimport scripts from \"./scripts\";\nimport transactions from \"./transactions\";\n\nexport default {\n  contracts,\n  scripts,\n  transactions,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {config} from \"@onflow/config\"\nimport {withPrefix} from \"./address\"\nimport {hexContract} from \"./deploy-code\"\nimport registry from \"./generated\"\n\nexport const initManager = async () => {\n  const code = await registry.transactions.initManagerTemplate()\n  const contractCode = await registry.contracts.FlowManagerTemplate()\n  const hexedContract = hexContract(contractCode)\n  const args = [hexedContract]\n\n  await sendTransaction({\n    code,\n    args,\n    service: true,\n  })\n}\n\nexport const getServiceAddress = async () => {\n  return withPrefix(await config().get(\"SERVICE_ADDRESS\"))\n}\n\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress()\n\n  const addressMap = {\n    FlowManager: serviceAddress,\n  }\n\n  const code = await registry.scripts.checkManagerTemplate(addressMap)\n\n  let [result, e] = await executeScript({\n    code,\n    service: true,\n  })\n  if (e && result === null) {\n    await initManager()\n  }\n\n  return getServiceAddress()\n}\n\n// TODO: replace method above after Cadence will allow to get contracts list on PublicAccount\n/*\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress();\n\n  const code = `\n    pub fun main(address: Address):Bool {\n      return getAccount(address).contracts.get(\"FlowManager\") != null\n    }\n  `;\n  const result = await executeScript({ code, args: [serviceAddress] });\n\n  if (!result) {\n    await initManager();\n  }\n\n  return serviceAddress;\n};\n */\n\nexport const getBlockOffset = async () => {\n  const FlowManager = await getManagerAddress()\n  const code = await registry.scripts.getBlockOffsetTemplate({FlowManager})\n  return executeScript({code})\n}\n\nexport const setBlockOffset = async offset => {\n  const FlowManager = await getManagerAddress()\n\n  const args = [offset]\n  const code = await registry.transactions.setBlockOffsetTemplate({FlowManager})\n  const payer = [FlowManager]\n\n  return sendTransaction({code, args, payer})\n}\n\nexport const getTimestampOffset = async () => {\n  const FlowManager = await getManagerAddress()\n  const code = await registry.scripts.getTimestampOffsetTemplate({FlowManager})\n  return executeScript({code})\n}\n\nexport const setTimestampOffset = async offset => {\n  const FlowManager = await getManagerAddress()\n\n  const args = [offset]\n  const code = await registry.transactions.setTimestampOffsetTemplate({\n    FlowManager,\n  })\n  const payer = [FlowManager]\n\n  return sendTransaction({code, args, payer})\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getManagerAddress} from \"./manager\"\nimport {executeScript} from \"./interaction\"\nimport {defaultsByName} from \"./file\"\n\nimport registry from \"./generated\"\n\n/**\n * Returns address of the account where contract specified by name is currently deployed\n * @param {string} name - name of the account to look for\n * @param {boolean} [useDefaults=false] - whether we shall look into default addressed first\n * @returns {Promise<string>}\n */\nexport const getContractAddress = async (name, useDefaults = false) => {\n  // TODO: Maybe try to automatically deploy contract? \n\n  if (useDefaults) {\n    const defaultContract = defaultsByName[name]\n    if (defaultContract !== undefined) {\n      return defaultContract\n    }\n  }\n\n  const managerAddress = await getManagerAddress()\n  const addressMap = {FlowManager: managerAddress}\n\n  const code = await registry.scripts.getContractAddressTemplate(addressMap)\n  const args = [name, managerAddress]\n  const [contractAddress] = await executeScript({\n    code,\n    args,\n    service: true,\n  })\n\n  return contractAddress\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getContractAddress} from \"./contract\"\nimport {defaultsByName} from \"./file\"\n\nconst REGEXP_IMPORT = /(\\s*import\\s*)([\\w\\d]+)(\\s+from\\s*)([\\w\\d\".\\\\/]+)/g\n\nconst getPairs = line => {\n  return line\n    .split(/\\s/)\n    .map(item => item.replace(/\\s/g, \"\"))\n    .filter(item => item.length > 0 && item !== \"import\" && item !== \"from\")\n}\n\nconst collect = (acc, item) => {\n  const [contract, address] = item\n  acc[contract] = address\n  return acc\n}\n\n/**\n * Returns address map for contracts defined in template code.\n * @param {string} code - Cadence code to parse.\n * @returns {*}\n */\nexport const extractImports = code => {\n  if (!code || code.length === 0) {\n    return {}\n  }\n  return code\n    .split(\"\\n\")\n    .filter(line => line.includes(\"import\"))\n    .map(getPairs)\n    .reduce(collect, {})\n}\n\nexport const replaceImports = (code, addressMap) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract) => {\n    const newAddress =\n      addressMap instanceof Function\n        ? addressMap(contract)\n        : addressMap[contract]\n    return `${imp}${contract} from ${newAddress}`\n  })\n}\n\n/**\n * Returns Cadence template code with replaced import addresses\n * @param {string} code - Cadence template code.\n * @param {{string:string}} [addressMap={}] - name/address map or function to use as lookup table\n * for addresses in import statements.\n * @param byName - lag to indicate whether we shall use names of the contracts.\n * @returns {*}\n */\nexport const replaceImportAddresses = (code, addressMap, byName = true) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract, _, address) => {\n    const key = byName ? contract : address\n    const newAddress =\n      addressMap instanceof Function ? addressMap(key) : addressMap[key]\n    return `${imp}${contract} from ${newAddress}`\n  })\n}\n\n/**\n * Resolves import addresses defined in code template\n * @param {string} code - Cadence template code.\n * @returns {{string:string}} - name/address map\n */\nexport const resolveImports = async code => {\n  const addressMap = {}\n  const importList = extractImports(code)\n  for (const key in importList) {\n    if (defaultsByName[key]) {\n      addressMap[key] = defaultsByName[key]\n    } else {\n      const address = await getContractAddress(key)\n      addressMap[key] = address\n    }\n  }\n  return addressMap\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from \"fs\"\nimport path from \"path\"\nimport {config} from \"@onflow/config\"\n\nimport {replaceImportAddresses} from \"./imports\"\nimport {isObject} from \"./utils\"\n\nexport const readFile = path => {\n  return fs.readFileSync(path, \"utf8\")\n}\n\n/**\n * Address map with access by name for contracts deployed to emulator by default.\n * @type {{FlowFees: string, FlowToken: string, FungibleToken: string}}\n */\nexport const defaultsByName = {\n  FlowToken: \"0x0ae53cb6e3f42a79\",\n  FungibleToken: \"0xee82856bf20e2aa6\",\n  FlowFees: \"0xe5a8b7f23e8b548f\",\n  FlowStorageFees: \"0xf8d6e0586b0a20c7\",\n}\n\n/**\n * Address map with access by address for contracts deployed to emulator by default.\n * @type {{\"0xe5a8b7f23e8b548f\": string, \"0xf8d6e0586b0a20c7\": string, \"0xee82856bf20e2aa6\": string, \"0x0ae53cb6e3f42a79\": string}}\n */\nexport const defaultsByAddress = {\n  \"0xe5a8b7f23e8b548f\": \"0xe5a8b7f23e8b548f\", // FlowFees\n  \"0xf8d6e0586b0a20c7\": \"0xf8d6e0586b0a20c7\", // FlowStorageFees\n  \"0x0ae53cb6e3f42a79\": \"0x0ae53cb6e3f42a79\", // FlowToken\n  \"0xee82856bf20e2aa6\": \"0xee82856bf20e2aa6\", // FungibleToken\n}\n\nconst SCRIPT = \"scripts\"\nconst TRANSACTION = \"transactions\"\nconst CONTRACT = \"contracts\"\n\nexport const templateType = {\n  SCRIPT,\n  TRANSACTION,\n  CONTRACT,\n}\n\nexport const getPath = async (name, type = TRANSACTION) => {\n  const configBase = await config().get(\"BASE_PATH\")\n\n  // We can simply overwrite \"configBase\" variable, but I believe it's better to leave it unchanged\n  let basePath = configBase\n\n  // It's possible to pass a set of paths via object, so we need to check if that's the case\n  if (isObject(configBase)) {\n    const typePath = configBase[type]\n\n    // if there is a specific path for this type, then we shall resolve it\n    if (typePath) {\n      return path.resolve(typePath, `./${name}.cdc`)\n    }\n\n    // otherwise use \"base\" value\n    basePath = configBase.base\n  }\n\n  return path.resolve(basePath, `./${type}/${name}.cdc`)\n}\n\n/**\n * Returns Cadence template for specified file. Replaces imports using provided address map\n * @param file - name of the file to look for.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [byAddress=false] - flag to indicate if address map is address to address type.\n * @returns {string}\n */\nexport const getTemplate = (file, addressMap = {}, byAddress = false) => {\n  const rawCode = readFile(file)\n\n  const defaults = byAddress ? defaultsByAddress : defaultsByName\n\n  return addressMap\n    ? replaceImportAddresses(rawCode, {\n        ...defaults,\n        ...addressMap,\n      })\n    : rawCode\n}\n\n/**\n * Returns contract template using name of the file in \"contracts\" folder containing the code.\n * @param name - name of the contract template in \"contract\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getContractCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.CONTRACT)\n  return getTemplate(path, addressMap)\n}\n\n/**\n * Returns transaction template using name of the file in \"transactions\" folder containing the code.\n * @param name - name of the transaction template in \"transactions\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getTransactionCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.TRANSACTION)\n  return getTemplate(path, addressMap)\n}\n\n/**\n * Returns script template using name of the file in \"scripts\" folder containing the code.\n * @param name - name of the script template in \"scripts\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getScriptCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.SCRIPT)\n  return getTemplate(path, addressMap)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport registry from \"./generated\"\nimport {defaultsByName} from \"./file\"\n\nconst FlowTokenMap = {ExampleToken: defaultsByName.FlowToken}\n\nconst lowerFirst = name => {\n  return name[0].toLowerCase() + name.slice(1)\n}\n\nexport const makeMintTransaction = async name => {\n  const code = await registry.transactions.mintTokensTemplate(FlowTokenMap)\n  const pattern = /(ExampleToken)/gi\n\n  return code.replace(pattern, match => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name)\n  })\n}\n\nexport const makeGetBalance = async name => {\n  const code = await registry.scripts.getBalanceTemplate(FlowTokenMap)\n  const pattern = /(ExampleToken)/gi\n\n  return code.replace(pattern, match => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name)\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {expect} = global\n\n/**\n * Return Promise from passed interaction\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*>\n * */\nexport const promise = async ix => {\n  if (typeof ix === \"function\") {\n    return await ix()\n  }\n  return await ix\n}\n\n/**\n * Ensure transaction did not throw and sealed.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - transaction result\n * */\nexport const shallPass = async ix => {\n  const wrappedInteraction = promise(ix)\n\n  const response = await wrappedInteraction\n  const [result, error] = response\n\n  if (error) {\n    throw error\n  }\n\n  let resolvedStatus\n  let resolvedErrorMessage\n  if (Array.isArray(result)) {\n    const {status, errorMessage} = result\n    resolvedStatus = status\n    resolvedErrorMessage = errorMessage\n  } else {\n    const {status, errorMessage} = result\n    resolvedStatus = status\n    resolvedErrorMessage = errorMessage\n  }\n\n  await expect(resolvedStatus).toBe(4)\n  await expect(resolvedErrorMessage).toBe(\"\")\n\n  return response\n}\n\n/**\n * Ensure interaction did not throw and return result of it\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - result of interaction\n * */\nexport const shallResolve = async ix => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n  const [, error] = response\n  expect(error).toBe(null)\n\n  return response\n}\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @param {string | RegExp} [message] - Expected error message provided as either a string equality or regular expression\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallRevert = async (ix, message) => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n  const [result, error] = response\n\n  await expect(result).toBe(null)\n\n  if (message) {\n    const errorMessage = error\n      .toString()\n      .match(/^error: (panic)|(assertion failed): ([^\\r\\n]*)$/m)\n      ?.at(3)\n    if (message instanceof RegExp) {\n      await expect(errorMessage).toMatch(message)\n    } else {\n      await expect(errorMessage).toBe(message)\n    }\n  } else {\n    await expect(error).not.toBe(null)\n  }\n\n  return response\n}\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallThrow = async ix => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n\n  const [result, error] = response\n  await expect(result).toBe(null)\n  await expect(error).not.toBe(null)\n\n  return response\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {send, build, getBlock, decode} from \"@onflow/fcl\"\nimport {config} from \"@onflow/config\"\nimport {getAvailablePorts} from \"./utils\"\n\nconst {spawn} = require(\"child_process\")\n\nconst DEFAULT_HTTP_PORT = 8080\nconst DEFAULT_GRPC_PORT = 3569\n\nconst print = {\n  log: console.log,\n  service: console.log,\n  info: console.log,\n  error: console.error,\n  warn: console.warn,\n}\n\n/** Class representing emulator */\nexport class Emulator {\n  /**\n   * Create an emulator.\n   */\n  constructor() {\n    this.initialized = false\n    this.logging = false\n    this.filters = []\n    this.logProcessor = item => item\n  }\n\n  /**\n   * Set logging flag.\n   * @param {boolean} logging - whether logs shall be printed\n   */\n  setLogging(logging) {\n    this.logging = logging\n  }\n\n  /**\n   * Log message with a specific type.\n   * @param {*} message - message to put into log output\n   * @param {\"log\"|\"error\"} type - type of the message to output\n   */\n  log(message, type = \"log\") {\n    if (this.logging !== false) {\n      print[type](message)\n    }\n  }\n\n  checkLevel(message, level) {\n    if (level === \"debug\") {\n      // We might need to find a better way for this, but this will do for now...\n      return message.includes(\"LOG\") ? \"log\" : level\n    }\n    return level\n  }\n\n  extractKeyValue(str) {\n    // TODO: add regexp check that it conforms to necessary pattern\n    const [key, value] = str.split(\"=\")\n    if (value.includes(\"LOG\")) {\n      return {key, value: value.replace(`\"\\x1b[1;34m`, `\"\\x1b[1[34m`)}\n    }\n    return {key, value}\n  }\n\n  fixJSON(msg) {\n    const splitted = msg.split(\"\\n\").filter(item => item !== \"\")\n    const reconstructed =\n      splitted.length > 1 ? `[${splitted.join(\",\")}]` : splitted[0]\n    return reconstructed\n  }\n\n  parseDataBuffer(data) {\n    const message = data.toString()\n    try {\n      if (message.includes(\"msg\")) {\n        return JSON.parse(this.fixJSON(message))\n      }\n    } catch (e) {\n      console.error(e)\n      return {msg: e, level: \"JSON Error\"}\n    }\n    return {msg: message, level: \"parser\"}\n  }\n\n  /**\n   * Start emulator.\n   * @param {number} port - port to use for accessApi\n   * @param {boolean} logging - whether logs shall be printed\n   * @returns Promise<*>\n   */\n  async start(options = {}) {\n    // populate emulator ports with available ports\n    ;[this.grpcPort, this.restPort, this.adminPort] = await getAvailablePorts(3)\n\n    // override ports if specified in options\n    this.grpcPort = options.grpcPort || this.grpcPort\n    this.restPort = options.restPort || this.restPort\n    this.adminPort = options.adminPort || this.adminPort\n\n    // Support deprecated start call using static port\n    if (arguments.length > 1 || typeof arguments[0] === \"number\") {\n      console.warn(`Calling emulator.start with the port argument is now deprecated in favour of dynamically selected ports and will be removed in future versions of flow-js-testing.\nPlease refrain from supplying this argument, as using it may cause unintended consequences.\nMore info: https://github.com/onflow/flow-js-testing/blob/master/TRANSITIONS.md#001-deprecate-emulatorstart-port-argument`)\n      ;[this.adminPort, options = {}] = arguments\n\n      const offset = this.adminPort - DEFAULT_HTTP_PORT\n      this.grpcPort = DEFAULT_GRPC_PORT + offset\n    }\n\n    const {flags = \"\", logging = false} = options\n\n    // config access node\n    config().put(\"accessNode.api\", `http://localhost:${this.restPort}`)\n\n    this.logging = logging\n    this.process = spawn(\"flow\", [\n      \"emulator\",\n      \"--verbose\",\n      `--log-format=JSON`,\n      `--rest-port=${this.restPort}`,\n      `--admin-port=${this.adminPort}`,\n      `--port=${this.grpcPort}`,\n      flags,\n    ])\n    this.logProcessor = item => item\n\n    // Suppress logger warning while waiting for emulator\n    await config().put(\"logger.level\", 0)\n\n    return new Promise((resolve, reject) => {\n      let internalId\n      const checkLiveness = async function () {\n        try {\n          await send(build([getBlock(false)])).then(decode)\n          clearInterval(internalId)\n\n          // Enable logger after emulator has come online\n          await config().put(\"logger.level\", 2)\n          this.initialized = true\n          resolve(true)\n        } catch (err) {} // eslint-disable-line no-unused-vars, no-empty\n      }\n      internalId = setInterval(checkLiveness, 100)\n\n      this.process.stdout.on(\"data\", buffer => {\n        const data = this.parseDataBuffer(buffer)\n        if (Array.isArray(data)) {\n          let filtered = []\n          if (this.filters.length > 0) {\n            filtered = data.filter(item => {\n              const level = this.checkLevel(item.msg, item.level)\n              return this.filters.includes(level)\n            })\n          }\n          for (let i = 0; i < filtered.length; i++) {\n            const item = data[i]\n            const {msg} = item\n            const level = this.checkLevel(msg, item.level)\n            this.log(`${level.toUpperCase()}: ${msg}`)\n          }\n        } else {\n          const {msg} = data\n          const level = this.checkLevel(msg, data.level)\n          if (this.filters.length > 0) {\n            if (this.filters.includes(level)) {\n              this.log(`${level.toUpperCase()}: ${msg}`)\n              // TODO: Fix this\n              // This is really hacky solution, which depends on specific phrasing\n              if (msg.includes(\"Starting\") && msg.includes(this.adminPort)) {\n                this.log(\"EMULATOR IS UP! Listening for events!\")\n              }\n            }\n          } else {\n            this.log(`${level.toUpperCase()}: ${msg}`)\n            if (data.msg.includes(\"Starting HTTP server\")) {\n              this.log(\"EMULATOR IS UP! Listening for events!\")\n            }\n          }\n        }\n      })\n\n      this.process.stderr.on(\"data\", buffer => {\n        const {message} = this.parseDataBuffer(buffer)\n        this.log(`EMULATOR ERROR: ${message}`, \"error\")\n        this.initialized = false\n        clearInterval(internalId)\n        reject()\n      })\n\n      this.process.on(\"close\", code => {\n        if (this.filters.includes(\"service\")) {\n          this.log(`EMULATOR: process exited with code ${code}`)\n        }\n        this.initialized = false\n        clearInterval(internalId)\n        resolve(false)\n      })\n    })\n  }\n\n  /**\n   * Clear all log filters.\n   * @returns void\n   **/\n  clearFilters() {\n    this.filters = []\n  }\n\n  /**\n   * Remove specific type of log filter.\n   * @param {(debug|info|warning)} type - type of message\n   * @returns void\n   **/\n  removeFilter(type) {\n    this.filters = this.filters.filter(item => item !== type)\n  }\n\n  /**\n   * Add log filter.\n   * @param {(debug|info|warning)} type type - type of message\n   * @returns void\n   **/\n  addFilter(type) {\n    if (!this.filters.includes(type)) {\n      this.filters.push(type)\n    }\n  }\n\n  /**\n   * Stop emulator.\n   * @returns Promise<*>\n   */\n  async stop() {\n    // eslint-disable-next-line no-undef\n    return new Promise(resolve => {\n      this.process.kill()\n      setTimeout(() => {\n        this.initialized = false\n        resolve(false)\n      }, 50)\n    })\n  }\n}\n\n/** Singleton instance */\nexport default new Emulator()\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getServiceAddress} from \"./manager\"\n\nexport const importManager = async () => {\n  const serviceAddress = await getServiceAddress()\n  return `import FlowManager from ${serviceAddress}`\n}\n\nexport const importExists = (contractName, code) => {\n  return new RegExp(`import\\\\s+${contractName}`).test(code)\n}\n\nexport const builtInMethods = async code => {\n  let injectedImports = code\n  if (!importExists(\"FlowManager\", code)) {\n    const imports = await importManager()\n    injectedImports = `\n      ${imports}\n      ${code}  \n  `\n  }\n  return injectedImports\n    .replace(/getCurrentBlock\\(\\).height/g, `FlowManager.getBlockHeight()`)\n    .replace(\n      /getCurrentBlock\\(\\).timestamp/g,\n      `FlowManager.getBlockTimestamp()`\n    )\n}\n\nconst addressToIndex = address => {\n  return parseInt(address) - 1\n}\n\nconst addressToAlias = accounts => address => accounts[addressToIndex(address)]\n\nexport const playgroundImport = accounts => async code => {\n  let injectedImports = code\n  if (!importExists(\"FlowManager\", code)) {\n    const imports = await importManager()\n    injectedImports = `\n      ${imports}\n      ${code}  \n  `\n  }\n  return injectedImports.replace(/(?:getAccount\\()(.+)(?:\\))/g, (match, g1) => {\n    const alias = addressToAlias(accounts)(g1)\n    if (!alias) {\n      return `getAccount(FlowManager.resolveDefaultAccounts(${g1}))`\n    }\n    return `getAccount(FlowManager.getAccountAddress(\"${alias}\"))`\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {pubFlowKey} from \"./crypto\"\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {getManagerAddress} from \"./manager\"\n\nimport registry from \"./generated\"\n\n/**\n * Returns address of account specified by name. If account with that name doesn't exist it will be created\n * and assigned provided name as alias\n * @param {string} accountName - name of the account\n * @returns {Promise<string|*>}\n */\nexport const getAccountAddress = async accountName => {\n  const name =\n    accountName ||\n    `deployment-account-${(Math.random() * Math.pow(10, 8)).toFixed(0)}`\n\n  const managerAddress = await getManagerAddress()\n\n  const addressMap = {\n    FlowManager: managerAddress,\n  }\n\n  let accountAddress\n\n  const code = await registry.scripts.getAccountAddressTemplate(addressMap)\n\n  const args = [name, managerAddress]\n\n  const [result] = await executeScript({\n    code,\n    args,\n    service: true,\n  })\n  accountAddress = result\n\n  if (accountAddress === null) {\n    const code = await registry.transactions.createAccountTemplate(addressMap)\n    const publicKey = await pubFlowKey()\n    const args = [name, publicKey, managerAddress]\n\n    const [result] = await sendTransaction({\n      code,\n      args,\n    })\n    const {events} = result\n    const event = events.find(event => event.type.includes(\"AccountAdded\"))\n    accountAddress = event.data.address\n  }\n  return accountAddress\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {defaultsByName} from \"./file\"\nimport {replaceImportAddresses} from \"./imports\"\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {makeGetBalance, makeMintTransaction} from \"./templates\"\n\n/**\n * Returns current FlowToken balance of account specified by address\n * @param {string} address - address of account to check\n * @returns {Promise<*>}\n */\nexport const getFlowBalance = async address => {\n  const raw = await makeGetBalance(\"FlowToken\")\n  const code = replaceImportAddresses(raw, defaultsByName)\n  const args = [address]\n\n  return executeScript({code, args})\n}\n\n/**\n * Sends transaction to mint specified amount of FlowToken and send it to recipient.\n * Returns result of the transaction.\n * @param {string} recipient - address of recipient account\n * @param {string} amount - amount to mint and send\n * @returns {Promise<*>}\n */\nexport const mintFlow = async (recipient, amount) => {\n  const raw = await makeMintTransaction(\"FlowToken\")\n  const code = replaceImportAddresses(raw, defaultsByName)\n  const args = [recipient, amount]\n  return sendTransaction({code, args})\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {set} from \"./config\"\n\n/**\n * Inits framework variables, storing private key of service account and base path\n * where Cadence files are stored.\n * @param {string} basePath - path to the folder with Cadence files to be tested.\n * @param {number} [props.port] - port to use for accessAPI\n * @param {number} [props.pkey] - private key to use for service account in case of collisions\n */\nexport const init = async (basePath, props = {}) => {\n  const {\n    pkey = \"48a1f554aeebf6bf9fe0d7b5b79d080700b073ee77909973ea0b2f6fbc902\",\n  } = props\n\n  set(\"PRIVATE_KEY\", process.env.PK, \"accounts/emulator-account/key\", pkey)\n  set(\n    \"SERVICE_ADDRESS\",\n    process.env.SERVICE_ADDRESS,\n    \"accounts/emulator-account/address\",\n    \"f8d6e0586b0a20c7\"\n  )\n  set(\"BASE_PATH\", process.env.BASE_PATH, \"testing/paths\", basePath)\n}\n"],"names":["get","scope","path","fallback","split","length","head","rest","_error","set","key","env","conf","value","flowConfig","config","put","sansPrefix","address","replace","withPrefix","ec","EC","signWithKey","privateKey","msgHex","sig","keyFromPrivate","Buffer","from","sign","sha","SHA3","update","digest","hashMsgHex","r","toArrayLike","s","concat","toString","authorization","addr","keyId","account","serviceAddress","pkey","tempId","fcl","signingFunction","data","signature","message","isObject","arg","getAvailablePorts","count","Promise","resolve","reject","server","createServer","listen","port","close","err","_settle","pact","state","_Pact","o","bind","v","then","observer","prototype","onFulfilled","onRejected","result","this","callback","e","_this","body","recover","extractParameters","ixType","params","getServiceAddress","code","ixCode","signers","ixSigners","args","ixArgs","limit","ixLimit","addressMap","defaultsByName","deployedContracts","FlowManager","replaceImportAddresses","target","check","keys","push","array","i","_cycle","thenable","transformer","ixTransformers","ixService","resolveImports","ixName","props","name","transformers","service","Error","getScriptCode","getTransactionCode","sendTransaction","extractor","send","ix","response","tx","onceExecuted","serviceAuth","transaction","payer","proposer","auths","map","authorizations","resolveArguments","resolvedArgs","executeScript","decode","script","CODE","createAccountTemplate","getEnvironment","envMap","fullMap","reportMissingImports","deployContractTemplate","initManagerTemplate","mintTokensTemplate","registerContractTemplate","scratchTemplate","setBlockOffsetTemplate","setTimestampOffsetTemplate","updateContractTemplate","createAccount","reportMissing","processed","mintTokens","registerContract","scratch","updateContract","txRegistry","hexContract","contract","ixTo","ixAddressMap","ixUpdate","to","deployContract","contractCode","extractContractParameters","containerAddress","managerAddress","hexedCode","deployArgs","schema","generateSchema","item","splitArgs","argLetter","argList","contractName","transactions","getManagerAddress","registry","hexedContract","initManager","getContractAddress","useDefaults","defaultContract","undefined","contractAddress","REGEXP_IMPORT","getPairs","line","filter","collect","acc","extractImports","includes","reduce","byName","match","imp","_","Function","_forTo","FlowToken","FungibleToken","FlowFees","FlowStorageFees","defaultsByAddress","getPath","type","configBase","basePath","typePath","base","getTemplate","file","byAddress","rawCode","fs","readFileSync","readFile","getContractCode","TRANSACTION","FlowTokenMap","ExampleToken","lowerFirst","toLowerCase","slice","expect","global","promise","spawn","require","print","log","console","info","error","warn","constructor","initialized","logging","filters","logProcessor","setLogging","checkLevel","level","extractKeyValue","str","fixJSON","msg","splitted","join","parseDataBuffer","JSON","parse","start","options","arguments","grpcPort","restPort","adminPort","_arguments","flags","process","internalId","setInterval","build","getBlock","clearInterval","_this2","stdout","on","buffer","Array","isArray","filtered","toUpperCase","stderr","clearFilters","removeFilter","addFilter","stop","_this3","kill","setTimeout","injectedImports","RegExp","test","importExists","importManager","imports","resolvedAddress","accountName","Math","random","pow","toFixed","accountAddress","_Buffer","publicKey","getPublic","rlp","encode","pubFlowKey","events","event","find","makeGetBalance","raw","recipient","amount","makeMintTransaction","offset","wrappedInteraction","resolvedStatus","resolvedErrorMessage","status","errorMessage","toBe","not","_error$toString$match","at","toMatch"],"mappings":"wgCA4BaA,EAAM,CAACC,EAAOC,EAAMC,KAC/B,GAAoB,iBAATD,EAAmB,OAAOF,EAAIC,EAAOC,EAAKE,MAAM,KAAMD,GACjE,IAAKD,EAAKG,OAAQ,OAAOJ,EACzB,IACE,MAAOK,KAASC,GAAQL,EACxB,OAAOF,EAAIC,EAAMK,GAAOC,EAAMJ,GAC9B,MAAOK,GACP,OAAOL,IAWEM,EAAM,CAACC,EAAKC,EAAKC,EAAMT,KAClC,IAAIU,EAAQb,EAAIc,eAAcF,EAAMT,GAC/BU,IACHA,EAAQV,GAEVY,WAASC,IAAIN,EAAKG,ICjCPI,EAAaC,GACT,MAAXA,OACGA,EAAQC,QAAQ,MAAO,IAGnBC,EAAaF,GACT,MAAXA,OACG,KAAOD,EAAWC,GCDrBG,EAAK,IAAIC,KAAG,QAQLC,EAAc,CAACC,EAAYC,KACtC,MACMC,EADML,EAAGM,eAAeC,OAAOC,KAAKL,EAAY,QACtCM,KARCL,CAAAA,IACjB,MAAMM,EAAM,IAAIC,OAAK,KAErB,OADAD,EAAIE,OAAOL,OAAOC,KAAKJ,EAAQ,QACxBM,EAAIG,UAKUC,CAAWV,IAE1BW,EAAIV,EAAIU,EAAEC,YAAYT,OAAQ,KAD1B,IAEJU,EAAIZ,EAAIY,EAAED,YAAYT,OAAQ,KAF1B,IAGV,OAAOA,OAAOW,OAAO,CAACH,EAAGE,IAAIE,SAAS,QAG3BC,EACX,CAACC,EAAMC,EAAQ,aACRC,EAAU,+BACc7B,WAASf,IAAI,kCAApC6C,0BACa9B,WAASf,IAAI,8BAA1B8C,GAUN,OARAJ,EAAOzB,EAAWyB,GAAQG,GAQnB,IACFD,EACHG,OAAS,GAAEL,KAAQC,IACnBD,KAAMM,EAAI/B,WAAWyB,GACrBC,MAAAA,EACAM,yBAX4BC,8BAAS,CACrCP,MAAAA,EACAD,KAAMtB,EAAWsB,GACjBS,UAAW5B,EAAYuB,EAAMI,EAAKE,oDAVtC,oCCtBWC,EAAWC,GAAsB,iBAARA,GAA4B,OAARA,WAE1CC,EAAkBC,EAAQ,GACxC,OAAc,IAAVA,EAAoBC,QAAQC,QAAQ,QAC7BD,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAASC,iBACfD,EAAOE,OAAO,EAAG,KACf,MAAMC,EAAOH,EAAO1C,UAAU6C,KAC9BH,EAAOI,eAAYC,OAAO,OACpBA,GAAKN,EAAOM,mBACGV,EAAkBC,EAAQ,qBAA7CE,EAAQ,MAA0CK,MAFpD,yCCWC,SAASG,EAAQC,EAAMC,EAAOvD,GACpC,IAAKsD,EAAK7B,EAAG,CACZ,GAAIzB,aAAiBwD,EAAO,CAC3B,IAAIxD,EAAMyB,EAOT,YADAzB,EAAMyD,EAAIJ,EAAQK,KAAK,KAAMJ,EAAMC,IALvB,EAARA,IACHA,EAAQvD,EAAMyB,GAEfzB,EAAQA,EAAM2D,EAMhB,GAAI3D,GAASA,EAAM4D,KAElB,YADA5D,EAAM4D,KAAKP,EAAQK,KAAK,KAAMJ,EAAMC,GAAQF,EAAQK,KAAK,KAAMJ,EAAM,IAGtEA,EAAK7B,EAAI8B,EACTD,EAAKK,EAAI3D,EACT,MAAM6D,EAAWP,EAAKG,EAClBI,GACHA,EAASP,IAlCZ,QAzBmC,WAClC,cAiCA,OAhCAE,EAAMM,UAAUF,KAAO,SAASG,EAAaC,GAC5C,MAAMC,EAAS,MACTV,EAAQW,KAAKzC,EACnB,GAAI8B,EAAO,CACV,MAAMY,EAAmB,EAARZ,EAAYQ,EAAcC,EAC3C,GAAIG,EAAU,CACb,IACCd,EAAQY,EAAQ,EAAGE,EAASD,KAAKP,IAChC,MAAOS,GACRf,EAAQY,EAAQ,EAAGG,GAEpB,OAAOH,EAEP,YAiBF,OAdAC,KAAKT,EAAI,SAASY,GACjB,IACC,MAAMrE,EAAQqE,EAAMV,EACN,EAAVU,EAAM5C,EACT4B,EAAQY,EAAQ,EAAGF,EAAcA,EAAY/D,GAASA,GAC5CgE,EACVX,EAAQY,EAAQ,EAAGD,EAAWhE,IAE9BqD,EAAQY,EAAQ,EAAGjE,GAEnB,MAAOoE,GACRf,EAAQY,EAAQ,EAAGG,KAGdH,KAhC0B,GAijB5B,WAAgBK,EAAMC,GAC5B,IACC,IAAIN,EAASK,IACZ,MAAMF,GACP,OAAOG,EAAQH,GAEhB,OAAIH,GAAUA,EAAOL,KACbK,EAAOL,UAAK,EAAQW,GAErBN,QA/hBKO,EAAoBC,YAClBC,wDAsDkBC,oBAAvB3C,gBAeN,MAAO,CACL4C,KAAMC,EACNC,QAASC,EACTC,KAAMC,EACNC,MAAOC,GAlBT,MAAMC,EAAa,IACdC,MACAC,EACHC,YAAavD,GAGf6C,EAASW,GAAuBX,EAAQO,GA7DnB,QAmHlB,SAAgBK,EAAQnB,EAAMoB,GACpC,IAAIC,EAAO,GACX,IAAK,IAAI9F,KAAO4F,EACfE,EAAKC,KAAK/F,GAEX,OAnCM,SAAgBgG,EAAOvB,EAAMoB,GACnC,IAAYpC,EAAMR,EAAdgD,GAAK,EAwBT,OAvBA,SAASC,EAAO9B,GACf,IACC,OAAS6B,EAAID,EAAMrG,QAElB,IADAyE,EAASK,EAAKwB,KACA7B,EAAOL,KAAM,CAC1B,MAxD0BoC,EAwDP/B,gBAvD0B,EAAb+B,EAASvE,GA2DxC,YADAwC,EAAOL,KAAKmC,EAAQjD,IAAWA,EAASO,EAAQK,KAAK,KAAMJ,EAAO,MAAa,KAF/EW,EAASA,EAAON,EAOfL,EACHD,EAAQC,EAAM,EAAGW,GAEjBX,EAAOW,EAEP,MAAOG,GACRf,EAAQC,IAASA,EAAO,OAAc,EAAGc,GAtErC,IAAwB4B,EAyE9BD,GACOzC,GAUOqC,EAAM,SAASG,GAAK,gBAxDpBA,GAAqB,wBAEfG,EADKC,EAAeJ,IACRjB,qBAA3BA,MAsDoCP,CAAKqB,EAAKG,OAxDhCI,oCAjBhB,IAAIZ,EA/CiB,uBAgDjBa,yBAGwBC,GAAevB,qBAAzCS,MAFAA,EAAoBD,qCAhDtB,IAAIR,EAAQwB,EAAQtB,EAAWE,EAAQkB,EAAWD,EAAgBf,EAElE,GAAI3C,EAASkC,EAAO,IAAK,CACvB,MAAO4B,GAAS5B,GACV6B,KACJA,EADI3B,KAEJA,EAFII,KAGJA,EAHIF,QAIJA,EAJI0B,aAKJA,EALItB,MAMJA,EANIuB,QAOJA,GAAU,GACRH,EAIJ,GAFAH,EAAYM,GAEPF,IAAS3B,EACZ,MAAM8B,MACJ,8DAGJL,EAASE,EACT1B,EAASD,EAETG,EAAYD,EACZG,EAASD,EACTkB,EAAiBM,GAAgB,GACjCrB,EAAUD,MAEK,WAAXT,GACA4B,EAAQpB,EAAQE,EAASe,GAAkBxB,GAE3C2B,EAAQtB,EAAWE,EAAQE,EAASe,GAAkBxB,EAK5DS,EAAUA,GAzCQ,IAGG,sBAwCjBkB,EAxCiB,wBA0CN,WAAX5B,EAAsBkC,GAAgBC,IACX,CAACL,KAAMF,sBAApCxB,yDA3CJ,oCAyFWgC,uEAET,MAAMC,EAAYtC,EAAkB,MADlC,uBAEyCsC,oCAArClC,KAACA,EAADI,KAAOA,EAAPF,QAAaA,EAAbI,MAAsBA,wCA0BL/C,EAAI4E,KAAKC,kBAA1BC,0BACe9E,EAAI+E,GAAGD,GAAUE,8BAAhClD,GAEN,MAAO,CAACA,EAAQ,UA3BhB,MAAMmD,EAAcxF,IAGdoF,EAAK,CACT7E,EAAIkF,YAAYzC,GAChBzC,EAAImF,MAAMF,GACVjF,EAAIoF,SAASH,GACbjF,EAAI+C,MAAMA,IAIZ,GAAIJ,EAAS,CACX,MAAM0C,EAAQ1C,EAAQ2C,IAAIpH,GAAWuB,EAAcvB,IACnD2G,EAAGpB,KAAKzD,EAAIuF,eAAeF,SAG3BR,EAAGpB,KAAKzD,EAAIuF,eAAe,CAACN,KApB5B,sBAwBEpC,yBACyB2C,mBAAiB3C,EAAMJ,kBAA5CgD,GACNZ,EAAGpB,KAAKzD,EAAI6C,KAAK4C,oDAMZxD,GACP,MAAO,CAAC,KAAMA,MAlCU,oCA8CfyD,uEAET,MAAMf,EAAYtC,EAAkB,UADlC,uBAEgCsC,oCAA5BlC,KAACA,EAADI,KAAOA,EAAPE,MAAaA,wCAQI/C,EAAI4E,KAAKC,kBAA1BC,0BACe9E,EAAI2F,OAAOb,kBAA1BhD,GACN,MAAO,CAACA,EAAQ,UARhB,MAAM+C,EAAK,CAAC7E,EAAI4F,OAAOnD,GAAOzC,EAAI+C,MAAMA,oBAEpCF,yBACyB2C,mBAAiB3C,EAAMJ,kBAA5CgD,GACNZ,EAAGpB,KAAKzD,EAAI6C,KAAK4C,oDAKZxD,GACP,MAAO,CAAC,KAAMA,MAfQ,oCC1Jb4D,EAAQ,6nBAyBRC,WAA+B7C,EAAa,+BAClC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,oBAE9B5C,yBAAuBwC,EAAMI,KAVJ,oCCzBrBJ,EAAQ,knBA4BRM,WAAgClD,EAAa,+BACnC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,qBAE9B5C,yBAAuBwC,EAAMI,KAVH,oCC5BtBJ,EAAQ,kMAgBRO,WAA6BnD,EAAa,+BAChC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,kBAE9B5C,yBAAuBwC,EAAMI,KAVN,oCChBnBJ,EAAQ,45BAmCRQ,WAA4BpD,EAAa,+BAC/B8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,iBAE9B5C,yBAAuBwC,EAAMI,KAVP,oCCnClBJ,EAAQ,yZAmBRS,WAAkCrD,EAAa,+BACrC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,uBAE9B5C,yBAAuBwC,EAAMI,KAVD,oCCnBxBJ,EAAQ,yFAYRU,WAAyBtD,EAAa,+BAC5B8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,cAE9B5C,yBAAuBwC,EAAMI,KAVV,oCCZfJ,EAAQ,6JAeRW,WAAgCvD,EAAa,+BACnC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,qBAE9B5C,yBAAuBwC,EAAMI,KAVH,oCCftBJ,EAAQ,iKAeRY,WAAoCxD,EAAa,+BACvC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,yBAE9B5C,yBAAuBwC,EAAMI,KAVC,oCCf1BJ,EAAQ,mtBA6BRa,WAAgCzD,EAAa,+BACnC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,EAAMI,EAAU,qBAE9B5C,yBAAuBwC,EAAMI,KAVH,0CC7BpB,CACbH,sBAAAA,EACAa,uBT2CkCxC,EAAQ,QAC1C,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADC,uBAE9B2B,EAAsB7C,kBAAnCR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,oBAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,oBAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAP1B,2DS1CxBgC,0BR6CmChC,EAAQ,QAC3C,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADE,uBAE/BgC,EAAuBlD,kBAApCR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,qBAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,qBAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAPzB,oCQ3CzBiC,oBAAAA,uBP+BgCjC,EAAQ,QACxC,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADD,uBAE5BiC,EAAoBnD,kBAAjCR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,kBAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,kBAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAP5B,oCO7BtBkC,mBAAAA,EACAS,oBN+C+B3C,EAAQ,QACvC,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADF,uBAE3BkC,EAAmBpD,kBAAhCR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,iBAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,iBAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAP7B,oCM9CrBmC,yBAAAA,EACAS,0BL6BqC5C,EAAQ,QAC7C,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADI,uBAEjCmC,EAAyBrD,kBAAtCR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,uBAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,uBAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAPvB,oCK5B3BoC,gBAAAA,EACAS,iBJoB4B7C,EAAQ,QACpC,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADL,uBAExBoC,EAAgBtD,kBAA7BR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,cAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,cAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAPhC,oCInBlBqC,uBAAAA,0BHsBmCrC,EAAQ,QAC3C,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADE,uBAE/BqC,EAAuBvD,kBAApCR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,qBAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,qBAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAPzB,oCGpBzBsC,2BAAAA,8BFoBuCtC,EAAQ,QAC/C,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADM,uBAEnCsC,EAA2BxD,kBAAxCR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,yBAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,yBAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAPrB,2DElB7BuC,EACAO,wBD+BmC9C,EAAQ,QAC3C,MAAMlB,WAAEA,EAAFJ,KAAcA,EAAO,GAArBF,QAAyBA,EAAU,IAAOwB,EADE,uBAE/BuC,EAAuBzD,kBAApCR,GAKN,OAHAmE,gBAAc,YAAa/D,EAAKxF,OAAQ,EAAI,qBAC5CuJ,gBAAc,UAAWjE,EAAQtF,OAAQ,EAAI,qBAEtCqH,kBAAgB,CAACjC,KAAAA,EAAMoE,WAAW,KAAS1C,MAPzB,qCE5B3B,MAAMuC,uBAACA,EAADP,uBAAyBA,GAA0Be,EAE5CC,EAAcC,GACzBxI,OAAOC,KAAKuI,EAAU,QAAQ5H,SAAS,OAEnC6C,YAA0BE,OAC9B,IAAI2B,EAAQmD,EAAMC,EAAcxE,EAAQyE,EAExC,GAAIlH,EAASkC,EAAO,IAAK,CACvB,MAAO4B,GAAS5B,GACV6B,KAACA,EAADoD,GAAOA,EAAPvE,WAAWA,EAAXJ,KAAuBA,EAAvB5D,OAA6BA,GAAUkF,EAE7C,IAAKC,EACH,MAAMG,MAAM,2BAGdL,EAASE,EACTiD,EAAOG,EACP1E,EAASD,EACTyE,EAAerE,EACfsE,EAAWtI,OAETiF,EAAQmD,EAAMC,EAAcxE,EAAQyE,GAAYhF,EAjBZ,uBAoBXC,oBAAvB3C,GACN,MAAMoD,EAAa,IACdC,GACHE,YAAavD,KACVyH,GAGL,MAAO,CACLlD,KAAMF,EACNsD,GAAIH,EACJxE,KAAMC,EACN7D,OAAQsI,EACRtE,WAAAA,KAhCmB,oCA0EVwE,YAAuBtD,OAClC,MAAMqD,GAACA,EAAI/E,KAAMiF,EAAXtD,KAAyBA,EAAzBvB,KAA+BA,EAA/B5D,OAAqCA,GAAUkF,EADV,uBAGtBwD,4BAA0BD,kBAAzCnF,cAIAqF,0BACuBpF,oBAAvBqF,0BAG0B5D,GAAeyD,kBAAzCvE,0BACuBX,oBAAvB3C,GACN,MAAMoD,EAAa,IACdC,MACAC,EACHC,YAAavD,GAGTiI,EAAYX,EAChB9D,GAAuBqE,EAAczE,IApBI,uBAuBhChE,EACDyH,EAAuBzD,GACvBkD,EAAuBlD,kBAF7BR,GAIJ,IAAIsF,EAAa,CAAC7D,EAAQ4D,EAAWD,GAErC,GAAIhF,EAAM,CACRkF,EAAaA,EAAWxI,OAAOsD,GAC/B,MAAMmF,EAASC,iBAAe1F,EAAOM,MAAMyC,IAAI4C,GAAQC,YAAUD,GAAM,IAEjEE,EAAY,6BAClB,IAAIC,EAAU,GACd,IAAK,IAAI1E,EAAI,EAAGA,EAAIqE,EAAO3K,OAAQsG,IAEjC0E,EAAQ5E,KAAM,GAAE2E,EAAUzE,OADZqE,EAAOrE,MAKvBlB,GADAA,EAAOA,EAAKtE,QAAQ,sBAAwB,KAAIoE,EAAOM,SAC3C1E,QAAQ,gBAAiBkK,QAGrC5F,GADAA,EAAOA,EAAKtE,QAAQ,sBAAwB,KAChCA,QAAQ,gBAAiB,IAKvC,OAAOuG,EAAgB,CACrBjC,KAAAA,EACAI,KAAMkF,EACNpF,QALc,CAACiF,aA3CjB,MAAM1D,EAASE,GAAQ7B,EAAO+F,aAJa,OAOlBd,IAAAA,mBAAahF,gBAPb,oCCrGdqD,GAAQ,4zHCCRA,GAAQ,+KCARA,GAAQ,sYCARA,GAAQ,8dCARA,GAAQ,uGCARA,GAAQ,yYCARA,GAAQ,kHCHnB0C,QC8BW/F,yCACazE,WAASf,IAAI,yBAA9BoB,GADqB,oCAIjBoK,yCACkBhG,oBAAvB3C,GADqC,gCPjBFoD,EAAa,+BACjC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,GAAMI,EAAU,mBAE9B5C,yBAAuBwC,GAAMI,KAVL,mCOwBZwC,CAJA,CACjBrF,YAAavD,mBAGT4C,0BAEkBiD,EAAc,CACpCjD,KAAAA,EACA6B,SAAS,oBAFNxC,EAAQG,0BAITA,GAAgB,OAAXH,+DA7BU2G,GAAsBrC,qCAAnC3D,mCRqHkCQ,EAAa,+BAChC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,GAAMI,EAAU,kBAE9B5C,yBAAuBwC,GAAMI,KAVN,mCQpHHwC,kBAArBf,GACN,MAAMgB,EAAgBvB,EAAYO,GAHG,uBAM/BhD,EAAgB,CACpBjC,KAAAA,EACAI,KAJW,CAAC6F,GAKZpE,SAAS,4BATW,mCA+BdqE,6DAGR,OAAOnG,OAAAA,WAjBqB,oCCXjBoG,YAA4BxE,EAAMyE,GAAc,OAG3D,GAAIA,EAAa,CACf,MAAMC,EAAkB5F,GAAekB,GACvC,QAAwB2E,IAApBD,EACF,uBAAOA,GAN0D,uBAUxCN,oBAAvBX,GAV+D,gCJDtB5E,EAAa,+BACvC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,GAAMI,EAAU,yBAE9B5C,yBAAuBwC,GAAMI,KAVC,mCIclBwC,CAFA,CAACrF,YAAayE,mBAE3BpF,GAb+D,uBAerCiD,EAAc,CAC5CjD,KAAAA,EACAI,KAHW,CAACuB,EAAMyD,GAIlBvD,SAAS,oBAHJ0E,IAMP,OAAOA,QArBsB,oCCSxB,SAAS9H,GAAQC,EAAMC,EAAOvD,GACpC,IAAKsD,EAAK7B,EAAG,CACZ,GAAIzB,aAAiBwD,GAAO,CAC3B,IAAIxD,EAAMyB,EAOT,YADAzB,EAAMyD,EAAIJ,GAAQK,KAAK,KAAMJ,EAAMC,IALvB,EAARA,IACHA,EAAQvD,EAAMyB,GAEfzB,EAAQA,EAAM2D,EAMhB,GAAI3D,GAASA,EAAM4D,KAElB,YADA5D,EAAM4D,KAAKP,GAAQK,KAAK,KAAMJ,EAAMC,GAAQF,GAAQK,KAAK,KAAMJ,EAAM,IAGtEA,EAAK7B,EAAI8B,EACTD,EAAKK,EAAI3D,EACT,MAAM6D,EAAWP,EAAKG,EAClBI,GACHA,EAASP,IAvCZ,MAAM8H,GAAgB,wDApBa,WAClC,cAiCA,OAhCA5H,EAAMM,UAAUF,KAAO,SAASG,EAAaC,GAC5C,MAAMC,EAAS,MACTV,EAAQW,KAAKzC,EACnB,GAAI8B,EAAO,CACV,MAAMY,EAAmB,EAARZ,EAAYQ,EAAcC,EAC3C,GAAIG,EAAU,CACb,IACCd,GAAQY,EAAQ,EAAGE,EAASD,KAAKP,IAChC,MAAOS,GACRf,GAAQY,EAAQ,EAAGG,GAEpB,OAAOH,EAEP,YAiBF,OAdAC,KAAKT,EAAI,SAASY,GACjB,IACC,MAAMrE,EAAQqE,EAAMV,EACN,EAAVU,EAAM5C,EACT4B,GAAQY,EAAQ,EAAGF,EAAcA,EAAY/D,GAASA,GAC5CgE,EACVX,GAAQY,EAAQ,EAAGD,EAAWhE,IAE9BqD,GAAQY,EAAQ,EAAGjE,GAEnB,MAAOoE,GACRf,GAAQY,EAAQ,EAAGG,KAGdH,KAhC0B,GAsB7BoH,GAAWC,GACRA,EACJ/L,MAAM,MACNkI,IAAI4C,GAAQA,EAAK/J,QAAQ,MAAO,KAChCiL,OAAOlB,GAAQA,EAAK7K,OAAS,GAAc,WAAT6K,GAA8B,SAATA,GAGtDmB,GAAU,CAACC,EAAKpB,KACpB,MAAOd,EAAUlJ,GAAWgK,EAE5B,OADAoB,EAAIlC,GAAYlJ,EACToL,GAQIC,GAAiB9G,GACvBA,GAAwB,IAAhBA,EAAKpF,OAGXoF,EACJrF,MAAM,MACNgM,OAAOD,GAAQA,EAAKK,SAAS,WAC7BlE,IAAI4D,IACJO,OAAOJ,GAAS,IANV,GA2BEhG,GAAyB,CAACZ,EAAMQ,EAAYyG,GAAS,IACzDjH,EAAKtE,QAAQ8K,GAAe,CAACU,EAAOC,EAAKxC,EAAUyC,EAAG3L,KAC3D,MAAMR,EAAMgM,EAAStC,EAAWlJ,EAGhC,MAAQ,GAAE0L,IAAMxC,UADdnE,aAAsB6G,SAAW7G,EAAWvF,GAAOuF,EAAWvF,OAUvDuG,YAAuBxB,OAClC,MAAMQ,EAAa,KA2Dd,SAAgBK,EAAQnB,EAAMoB,GACpC,IAAIC,EAAO,GACX,IAAK,IAAI9F,KAAO4F,EACfE,EAAKC,KAAK/F,GAEX,OAnCM,SAAgBgG,EAAOvB,EAAMoB,GACnC,IAAYpC,EAAMR,EAAdgD,GAAK,EAwBT,OAvBA,SAASC,EAAO9B,GACf,IACC,OAAS6B,EAAID,EAAMrG,QAElB,IADAyE,EAASK,EAAKwB,KACA7B,EAAOL,KAAM,CAC1B,MAxD0BoC,EAwDP/B,aAvDIT,IAAsB,EAAbwC,EAASvE,GA2DxC,YADAwC,EAAOL,KAAKmC,EAAQjD,IAAWA,EAASO,GAAQK,KAAK,KAAMJ,EAAO,IAAIE,GAAS,KAF/ES,EAASA,EAAON,EAOfL,EACHD,GAAQC,EAAM,EAAGW,GAEjBX,EAAOW,EAEP,MAAOG,GACRf,GAAQC,IAASA,EAAO,IAAIE,IAAU,EAAGY,GAtErC,IAAwB4B,EAyE9BD,GACOzC,EAUA4I,CAAOvG,EAAM,SAASG,GAAK,gBA9DtBjG,0BACLwF,GAAexF,0BAGKkL,GAAmBlL,kBAAnCQ,GACN+E,EAAWvF,GAAOQ,IAHlB+E,EAAWvF,GAAOwF,GAAexF,+CA4DGyE,CAAKqB,EAAKG,OA/D/B4F,GAAe9G,uDASlC,OAAOQ,IAAAA,GAXkB,oCCnDdC,GAAiB,CAC5B8G,UAAW,qBACXC,cAAe,qBACfC,SAAU,qBACVC,gBAAiB,sBAONC,GAAoB,CAC/B,qBAAsB,qBACtB,qBAAsB,qBACtB,qBAAsB,qBACtB,qBAAsB,sBAaXC,YAAiBjG,EAAMkG,EAThB,2CAUOvM,WAASf,IAAI,4BAAhCuN,GAGN,IAAIC,EAAWD,EAGf,GAAIlK,EAASkK,GAAa,CACxB,MAAME,EAAWF,EAAWD,GAG5B,GAAIG,EACF,OAAOvN,UAAKwD,QAAQ+J,EAAW,KAAIrG,SAIrCoG,EAAWD,EAAWG,KAGxB,OAAOxN,UAAKwD,QAAQ8J,EAAW,KAAIF,KAAQlG,WAnBzB,oCA6BPuG,GAAc,CAACC,EAAM3H,EAAa,GAAI4H,GAAY,KAC7D,MAAMC,EAlEgB5N,CAAAA,GACf6N,UAAGC,aAAa9N,EAAM,QAiEb+N,CAASL,GAIzB,OAAO3H,EACHI,GAAuByH,EAAS,IAHnBD,EAAYT,GAAoBlH,MAKxCD,IAEL6H,GASOI,aAAyB9G,KAACA,EAADnB,WAAOA,+BACxBoH,GAAQjG,EAzDZ,4BAyDTlH,GACN,OAAOyN,GAAYzN,EAAM+F,KAFC,oCAWfwB,aAA4BL,KAACA,EAADnB,WAAOA,+BAC3BoH,GAAQjG,EAhE3B+G,+BAgEMjO,GACN,OAAOyN,GAAYzN,EAAM+F,KAFI,oCAWlBuB,aAAuBJ,KAACA,EAADnB,WAAOA,+BACtBoH,GAAQjG,EAjFd,0BAiFPlH,GACN,OAAOyN,GAAYzN,EAAM+F,KAFD,oCC9GpBmI,GAAe,CAACC,aAAcnI,GAAe8G,WAE7CsB,GAAalH,GACVA,EAAK,GAAGmH,cAAgBnH,EAAKoH,MAAM,ICNtCC,OAACA,IAAUC,OAOJC,YAAgB9G,sDAIdA,yBAHK,mBAAPA,6BACIA,yDAFG,qCCJd+G,MAACA,IAASC,QAAQ,iBAKlBC,GAAQ,CACZC,IAAKC,QAAQD,IACbzH,QAAS0H,QAAQD,IACjBE,KAAMD,QAAQD,IACdG,MAAOF,QAAQE,MACfC,KAAMH,QAAQG,MAyOhB,iBAjOEC,cACErK,KAAKsK,aAAc,EACnBtK,KAAKuK,SAAU,EACfvK,KAAKwK,QAAU,GACfxK,KAAKyK,aAAetE,GAAQA,EAO9BuE,WAAWH,GACTvK,KAAKuK,QAAUA,EAQjBP,IAAI3L,EAASkK,EAAO,QACG,IAAjBvI,KAAKuK,SACPR,GAAMxB,GAAMlK,GAIhBsM,WAAWtM,EAASuM,GAClB,MAAc,UAAVA,GAEKvM,EAAQoJ,SAAS,OAAS,MAE5BmD,EAGTC,gBAAgBC,GAEd,MAAOnP,EAAKG,GAASgP,EAAIzP,MAAM,KAC/B,OAAIS,EAAM2L,SAAS,OACV,CAAC9L,IAAAA,EAAKG,MAAOA,EAAMM,QAAS,WAAe,aAE7C,CAACT,IAAAA,EAAKG,MAAAA,GAGfiP,QAAQC,GACN,MAAMC,EAAWD,EAAI3P,MAAM,MAAMgM,OAAOlB,GAAiB,KAATA,GAGhD,OADE8E,EAAS3P,OAAS,EAAK,IAAG2P,EAASC,KAAK,QAAUD,EAAS,GAI/DE,gBAAgBhN,GACd,MAAME,EAAUF,EAAKV,WACrB,IACE,GAAIY,EAAQoJ,SAAS,OACnB,OAAO2D,KAAKC,MAAMrL,KAAK+K,QAAQ1M,IAEjC,MAAO6B,GAEP,OADA+J,QAAQE,MAAMjK,GACP,CAAC8K,IAAK9K,EAAG0K,MAAO,cAEzB,MAAO,CAACI,IAAK3M,EAASuM,MAAO,UASzBU,MAAMC,EAAU,gBAElBvL,OAQEwL,UAVoB,uBAEgChN,EAAkB,sBAAxE2B,EAAKsL,SAAUtL,EAAKuL,SAAUvL,EAAKwL,aAGrCxL,EAAKsL,SAAWF,EAAQE,UAAYtL,EAAKsL,SACzCtL,EAAKuL,SAAWH,EAAQG,UAAYvL,EAAKuL,SACzCvL,EAAKwL,UAAYJ,EAAQI,WAAaxL,EAAKwL,WAGvCC,EAAUtQ,OAAS,GAA6B,mBAAP,MAC3C2O,QAAQG,KAAM,+XAGZjK,EAAKwL,UAAWJ,EAAU,MAG5BpL,EAAKsL,SADUtL,EAAKwL,UArGA,KACA,MAwGtB,MAAME,MAACA,EAAQ,GAATtB,QAAaA,GAAU,GAASgB,EApBd,OAuBxBvP,WAASC,IAAI,iBAAmB,oBAAmBkE,EAAKuL,YAExDvL,EAAKoK,QAAUA,EACfpK,EAAK2L,QAAUjC,GAAM,OAAQ,CAC3B,WACA,YACC,oBACA,eAAc1J,EAAKuL,WACnB,gBAAevL,EAAKwL,YACpB,UAASxL,EAAKsL,WACfI,IAEF1L,EAAKsK,aAAetE,GAAQA,kBAGtBnK,WAASC,IAAI,eAAgB,oBAEnC,WAAWyC,QAAQ,CAACC,EAASC,KAC3B,IAAImN,EAYJA,EAAaC,mCAJThM,OAqZH,SAAgBI,EAAMC,GAC5B,IACC,IAAIN,kBA5ZU8C,OAAKoJ,QAAM,CAACC,YAAS,MAAUxM,KAAKkE,2BADxC,OAEFuI,cAAcJ,mBAGR/P,WAASC,IAAI,eAAgB,oBACnCmQ,EAAK9B,aAAc,EACnB3L,GAAQ,OAuZf,MAAMuB,GACP,OAED,OAAIH,GAAUA,EAAOL,KACbK,EAAOL,UAAK,gBAEbK,mEAraiB,oCAWqB,KAExCI,EAAK2L,QAAQO,OAAOC,GAAG,OAAQC,IAC7B,MAAMpO,EAAOgC,EAAKgL,gBAAgBoB,GAClC,GAAIC,MAAMC,QAAQtO,GAAO,CACvB,IAAIuO,EAAW,GACXvM,EAAKqK,QAAQlP,OAAS,IACxBoR,EAAWvO,EAAKkJ,OAAOlB,IACrB,MAAMyE,EAAQzK,EAAKwK,WAAWxE,EAAK6E,IAAK7E,EAAKyE,OAC7C,SAAYJ,QAAQ/C,SAASmD,MAGjC,IAAK,IAAIhJ,EAAI,EAAGA,EAAI8K,EAASpR,OAAQsG,IAAK,CACxC,MAAMuE,EAAOhI,EAAKyD,IACZoJ,IAACA,GAAO7E,EACRyE,EAAQzK,EAAKwK,WAAWK,EAAK7E,EAAKyE,OACxCzK,EAAK6J,IAAK,GAAEY,EAAM+B,kBAAkB3B,UAEjC,CACL,MAAMA,IAACA,GAAO7M,EACRyM,EAAQzK,EAAKwK,WAAWK,EAAK7M,EAAKyM,OACpCzK,EAAKqK,QAAQlP,OAAS,EACpB6E,EAAKqK,QAAQ/C,SAASmD,KACxBzK,EAAK6J,IAAK,GAAEY,EAAM+B,kBAAkB3B,KAGhCA,EAAIvD,SAAS,aAAeuD,EAAIvD,SAAStH,EAAKwL,YAChDxL,EAAK6J,IAAI,2CAIb7J,EAAK6J,IAAK,GAAEY,EAAM+B,kBAAkB3B,KAChC7M,EAAK6M,IAAIvD,SAAS,yBACpBtH,EAAK6J,IAAI,6CAMjB7J,EAAK2L,QAAQc,OAAON,GAAG,OAAQC,IAC7B,MAAMlO,QAACA,GAAW8B,EAAKgL,gBAAgBoB,GACvCpM,EAAK6J,IAAK,mBAAkB3L,IAAW,SACvC8B,EAAKmK,aAAc,EACnB6B,cAAcJ,GACdnN,MAGFuB,EAAK2L,QAAQQ,GAAG,QAAS5L,IACnBP,EAAKqK,QAAQ/C,SAAS,YACxBtH,EAAK6J,IAAK,sCAAqCtJ,KAEjDP,EAAKmK,aAAc,EACnB6B,cAAcJ,GACdpN,GAAQ,WA1GH,mCAmHXkO,eACE7M,KAAKwK,QAAU,GAQjBsC,aAAavE,GACXvI,KAAKwK,QAAUxK,KAAKwK,QAAQnD,OAAOlB,GAAQA,IAASoC,GAQtDwE,UAAUxE,GACHvI,KAAKwK,QAAQ/C,SAASc,IACzBvI,KAAKwK,QAAQ9I,KAAK6G,GAQhByE,mBAGFhN,KADF,uBAAO,IAAItB,QAAQC,IACjBsO,EAAKnB,QAAQoB,OACbC,WAAW,KACTF,EAAK3C,aAAc,EACnB3L,GAAQ,IACP,OAPG,+DC9NwB+B,oBASlC,OAAO0M,EACJhR,QAAQ,8BAAgC,gCACxCA,QACC,iCACC,mCAZL,IAAIgR,EAAkB1M,EADoB,uBAJhB,EAAC6F,EAAc7F,QAC9B2M,OAAQ,yBAA4BC,KAAK5M,GAK/C6M,CAAa,EAAe7M,gEAVJD,oBAAvB3C,GACN,MAAQ,2BAA0BA,MAFV,mCAYA0P,kBAAhBC,GACNL,EAAmB,WACfK,YACA/M,+DANmB,qHhBqDJJ,4CAAfE,cAGAkN,0BACqBvE,GAAgB,CAAC9G,KAAAA,EAAMnB,WAAAA,mBAA5CyE,GAEN,MAAMxD,EAAS,QAAQmL,KAAKjL,GAAQ,KAAOA,EAE3C,OAAOqD,GAAe,CACpBD,GAAIiI,EACJhN,KAAMiF,EACNtD,KAAMF,EACNrB,KAAAA,EACA5D,OAAAA,MAZF,MAAMuI,GAACA,EAADpD,KAAKA,EAALnB,WAAWA,EAAXJ,KAAuBA,EAAvB5D,OAA6BA,GAAS,GAASsD,EAFC,OAI9BiF,IAAAA,mBAAahF,gBAJN,qHiBnDMkN,OACrC,MAAMtL,EACJsL,GACC,uBAAsBC,KAAKC,SAAWD,KAAKE,IAAI,GAAI,IAAIC,QAAQ,KAHd,uBAKvBtH,oBAAvBX,GAEN,MAAM5E,EAAa,CACjBG,YAAayE,GAGf,IAAIkI,EAXgD,gCdDN9M,EAAa,+BACtC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,GAAMI,EAAU,wBAE9B5C,yBAAuBwC,GAAMI,KAVA,mCccjBwC,CAA2CxF,kBAAxDR,GAb8C,uBAiB7BiD,EAAc,CACnCjD,KAAAA,EACAI,KAJW,CAACuB,EAAMyD,GAKlBvD,SAAS,oBAHJxC,IAKPiO,EAAiBjO,EAtBmC,sBAwB7B,OAAnBiO,yBACiBtH,GAAsB3C,sBAAsB7C,kBAAzDR,iD9BUKpE,EAAGM,iBACdC,SAAAoR,EAAOnR,4BAAWd,WAASf,IAAI,iCADjC,MAGMiT,SAHO5R,aACoC,QAE1B6R,UAAU,OAAO/R,QAAQ,MAAO,IACvD,OAAOgS,EACJC,OAAO,CACNxR,OAAOC,KAAKoR,EAAW,OACvB,EACA,EACA,MAEDzQ,SAAS,SAZS,mC8BRK6Q,kBAAlBJ,GA1B4C,uBA6B3BvL,EAAgB,CACrCjC,KAAAA,EACAI,KAJW,CAACuB,EAAM6L,EAAWpI,qBAExB/F,IAIP,MAAMwO,OAACA,GAAUxO,EACXyO,EAAQD,EAAOE,KAAKD,GAASA,EAAMjG,KAAKd,SAAS,iBACvDuG,EAAiBQ,EAAMrQ,KAAKhC,oDAE9B,OAAO6R,IAAAA,QArCqB,2FRoDFvH,oBAApBpF,mCJ3DqCH,EAAa,+BACnC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,GAAMI,EAAU,qBAE9B5C,yBAAuBwC,GAAMI,KAVH,mCI4DdwC,CAAwC,CAACrF,YAAAA,mBAAtDX,GACN,OAAOiD,EAAc,CAACjD,KAAAA,QAHG,8DxBtBS/E,OAClC,uBAAOK,WAASf,IAAIU,IADK,2GiC/BSQ,uCLQAkG,uCTPKnB,EAAa,+BAC/B8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,GAAMI,EAAU,iBAE9B5C,yBAAuBwC,GAAMI,KAVP,mCSQVwC,CAAoC2C,mBAAjD3I,GAGN,OAAOA,EAAKtE,QAFI,mBAEawL,GACV,iBAAVA,EAA2BvF,EAAOkH,GAAWlH,MAL7B,mCKPPqM,CAAe,4BAA3BC,GACN,MAAMjO,EAAOY,GAAuBqN,EAAKxN,IAGzC,OAAOwC,EAAc,CAACjD,KAAAA,EAAMI,KAFf,CAAC3E,OAHW,0JTsECsK,oBAApBpF,mCF3EyCH,EAAa,+BACvC8C,kCAAfC,GACN,MAAMC,EAAU,IACbD,KACA/C,GAMH,OAFAiD,uBAAqBL,GAAMI,EAAU,yBAE9B5C,yBAAuBwC,GAAMI,KAVC,mCE4ElBwC,CAA4C,CAACrF,YAAAA,mBAA1DX,GACN,OAAOiD,EAAc,CAACjD,KAAAA,QAHO,4EUtEJ+H,EAAUrG,EAAQ,QAC3C,MAAMrE,KACJA,EAAO,iEACLqE,EAH8C,OAKlD1G,EAAI,cAAeoQ,QAAgB,gCAAiC/N,GACpErC,EACE,kBACAoQ,QACA,oCACA,oBAEFpQ,EAAI,YAAaoQ,QAAuB,gBAAiBrD,qBAZ1C,wDDgBcmG,EAAWC,uCLhBDxM,8BACpBqE,GAAsBpC,mBAAmB+E,mBAAtD3I,GAGN,OAAOA,EAAKtE,QAFI,mBAEawL,GACV,iBAAVA,EAA2BvF,EAAOkH,GAAWlH,MALxB,mCKiBZyM,CAAoB,4BAAhCH,GACN,MAAMjO,EAAOY,GAAuBqN,EAAKxN,IAEzC,OAAOwB,EAAgB,CAACjC,KAAAA,EAAMI,KADjB,CAAC8N,EAAWC,OAHN,uJT4CeE,8BACRtI,oBAApBpF,GAEN,MAAMP,EAAO,CAACiO,GAH8B,uBAIzBrI,GAAsBjC,uBAAuB,CAACpD,YAAAA,mBAA3DX,GAGN,OAAOiC,EAAgB,CAACjC,KAAAA,EAAMI,KAAAA,EAAMsC,MAFtB,CAAC/B,SALU,kEAgBa0N,8BACZtI,oBAApBpF,GAEN,MAAMP,EAAO,CAACiO,GAHkC,uBAI7BrI,GAAsBhC,2BAA2B,CAClErD,YAAAA,mBADIX,GAKN,OAAOiC,EAAgB,CAACjC,KAAAA,EAAMI,KAAAA,EAAMsC,MAFtB,CAAC/B,SAPc,yDKlEAyB,OAC7B,MAAMkM,EAAqBpF,GAAQ9G,GADA,uBAGZkM,iBAAjBjM,GACN,MAAOhD,EAAQoK,GAASpH,EAExB,GAAIoH,EACF,MAAMA,EAGR,IAAI8E,EACAC,EACJ,GAAI1C,MAAMC,QAAQ1M,GAAS,CACzB,MAAMoP,OAACA,EAADC,aAASA,GAAgBrP,EAC/BkP,EAAiBE,EACjBD,EAAuBE,MAClB,CACL,MAAMD,OAACA,EAADC,aAASA,GAAgBrP,EAC/BkP,EAAiBE,EACjBD,EAAuBE,EAnBU,uBAsB7B1F,GAAOuF,GAAgBI,KAAK,2CAC5B3F,GAAOwF,GAAsBG,KAAK,qBAExC,OAAOtM,QAzBa,4DAiCYD,OAChC,MAAMkM,EAAqBpF,GAAQ9G,GADG,uBAEfkM,iBAAjBjM,GACN,OAASoH,GAASpH,EAGlB,OAFA2G,GAAOS,GAAOkF,KAAK,MAEZtM,IANgB,2DAeSD,EAAIzE,OACpC,MAAM2Q,EAAqBpF,GAAQ9G,GADa,uBAEzBkM,iBAAjBjM,GACN,MAAOhD,EAAQoK,GAASpH,EAHwB,uBAK1C2G,GAAO3J,GAAQsP,KAAK,8CAEtBhR,yBAWIqL,GAAOS,GAAOmF,IAAID,KAAK,iCAV7B,MAAMD,WAAejF,EAClB1M,WACAmK,MAAM,4DAFY2H,EAGjBC,GAAG,KACHnR,aAAmBgP,uBACf3D,GAAO0F,GAAcK,QAAQpR,uCAE7BqL,GAAO0F,GAAcC,KAAKhR,uGAMpC,OAAO0E,IAAAA,MArBe,0DA6BQD,OAC9B,MAAMkM,EAAqBpF,GAAQ9G,GADC,uBAEbkM,iBAAjBjM,GAEN,MAAOhD,EAAQoK,GAASpH,EAJY,uBAK9B2G,GAAO3J,GAAQsP,KAAK,8CACpB3F,GAAOS,GAAOmF,IAAID,KAAK,uBAE7B,OAAOtM,QARc"}
{"version":3,"file":"index.modern.js","sources":["../src/config.js","../src/init.js","../src/address.js","../src/crypto.js","../src/utils.js","../src/interaction.js","../src/generated/transactions/createAccount.js","../src/generated/transactions/deployContract.js","../src/generated/transactions/initManager.js","../src/generated/transactions/mintTokens.js","../src/generated/transactions/registerContract.js","../src/generated/transactions/scratch.js","../src/generated/transactions/setBlockOffset.js","../src/generated/transactions/setTimestampOffset.js","../src/generated/transactions/updateContract.js","../src/generated/transactions/index.js","../src/deploy-code.js","../src/generated/contracts/FlowManager.js","../src/generated/scripts/checkManager.js","../src/generated/scripts/getAccountAddress.js","../src/generated/scripts/getBalance.js","../src/generated/scripts/getBlockOffset.js","../src/generated/scripts/getContractAddress.js","../src/generated/scripts/getTimestampOffset.js","../src/generated/scripts/index.js","../src/generated/index.js","../src/manager.js","../src/contract.js","../src/imports.js","../src/file.js","../src/templates.js","../src/flow-token.js","../src/account.js","../src/jest-asserts.js","../src/transformers.js","../src/emulator.js"],"sourcesContent":["/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {flowConfig} from \"@onflow/fcl-config\"\nimport {config} from \"@onflow/config\"\n\n/**\n * Get value from provided scope and path.\n * @param scope - scope value.\n * @param path - value path in config (flow.json) file.\n * @param fallback - fallback value.\n * @returns {*} - value at specified scope and path.\n */\nexport const get = (scope, path, fallback) => {\n  if (typeof path === \"string\") return get(scope, path.split(\"/\"), fallback)\n  if (!path.length) return scope\n  try {\n    const [head, ...rest] = path\n    return get(scope[head], rest, fallback)\n  } catch (_error) {\n    return fallback\n  }\n}\n\n/**\n * Set globally available config value.\n * @param {string} key - key to be used to access stored value.\n * @param {string} env - value key in the environment (for example .env file).\n * @param {string} conf - value path in config (flow.json) file.\n * @param fallback - fallback value to be used if env and conf are absent.\n */\nexport const set = (key, env, conf, fallback) => {\n  let value = get(flowConfig(), conf, fallback)\n  if (!value) {\n    value = fallback\n  }\n  config().put(key, value)\n}\n\n/**\n * Returns config value at specified key.\n * @param key - key to the value.\n * @returns {Promise<*>} - value at specified key.\n */\nexport const getConfigValue = async key => {\n  return config().get(key)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {set} from \"./config\"\n\n/**\n * Inits framework variables, storing private key of service account and base path\n * where Cadence files are stored.\n * @param {string} basePath - path to the folder with Cadence files to be tested.\n * @param {number} [props.port] - port to use for accessAPI\n * @param {number} [props.pkey] - private key to use for service account in case of collisions\n */\nexport const init = async (basePath, props = {}) => {\n  const {\n    pkey = \"48a1f554aeebf6bf9fe0d7b5b79d080700b073ee77909973ea0b2f6fbc902\",\n  } = props\n\n  set(\"PRIVATE_KEY\", process.env.PK, \"accounts/emulator-account/key\", pkey)\n  set(\n    \"SERVICE_ADDRESS\",\n    process.env.SERVICE_ADDRESS,\n    \"accounts/emulator-account/address\",\n    \"f8d6e0586b0a20c7\"\n  )\n  set(\"BASE_PATH\", process.env.BASE_PATH, \"testing/paths\", basePath)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const sansPrefix = address => {\n  if (address == null) return null\n  return address.replace(/^0x/, \"\")\n}\n\nexport const withPrefix = address => {\n  if (address == null) return null\n  return \"0x\" + sansPrefix(address)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ec as EC} from \"elliptic\"\nimport {SHA3} from \"sha3\"\nimport * as fcl from \"@onflow/fcl\"\nimport * as rlp from \"rlp\"\nimport {config} from \"@onflow/config\"\nimport {sansPrefix, withPrefix} from \"./address\"\nconst ec = new EC(\"p256\")\n\nconst hashMsgHex = msgHex => {\n  const sha = new SHA3(256)\n  sha.update(Buffer.from(msgHex, \"hex\"))\n  return sha.digest()\n}\n\nexport const signWithKey = (privateKey, msgHex) => {\n  const key = ec.keyFromPrivate(Buffer.from(privateKey, \"hex\"))\n  const sig = key.sign(hashMsgHex(msgHex))\n  const n = 32 // half of signature length?\n  const r = sig.r.toArrayLike(Buffer, \"be\", n)\n  const s = sig.s.toArrayLike(Buffer, \"be\", n)\n  return Buffer.concat([r, s]).toString(\"hex\")\n}\n\nexport const authorization =\n  (addr, keyId = 0) =>\n  async (account = {}) => {\n    const serviceAddress = await config().get(\"SERVICE_ADDRESS\")\n    const pkey = await config().get(\"PRIVATE_KEY\")\n\n    addr = sansPrefix(addr || serviceAddress)\n\n    const signingFunction = async data => ({\n      keyId,\n      addr: withPrefix(addr),\n      signature: signWithKey(pkey, data.message),\n    })\n\n    return {\n      ...account,\n      tempId: `${addr}-${keyId}`,\n      addr: fcl.sansPrefix(addr),\n      keyId,\n      signingFunction,\n    }\n  }\n\nexport const pubFlowKey = async () => {\n  const keys = ec.keyFromPrivate(\n    Buffer.from(await config().get(\"PRIVATE_KEY\"), \"hex\")\n  )\n  const publicKey = keys.getPublic(\"hex\").replace(/^04/, \"\")\n  return rlp\n    .encode([\n      Buffer.from(publicKey, \"hex\"), // publicKey hex to binary\n      2, // P256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      3, // SHA3-256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      1000, // give key full weight\n    ])\n    .toString(\"hex\")\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {createServer} from \"net\"\n\nexport const isObject = arg => typeof arg === \"object\" && arg !== null\n\nexport function getAvailablePorts(count = 1) {\n  if (count === 0) return Promise.resolve([])\n  return new Promise((resolve, reject) => {\n    const server = createServer()\n    server.listen(0, () => {\n      const port = server.address().port\n      server.close(async err => {\n        if (err) reject(err)\n        resolve([...(await getAvailablePorts(count - 1)), port])\n      })\n    })\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fcl from \"@onflow/fcl\"\nimport {resolveArguments} from \"@onflow/flow-cadut\"\nimport {authorization} from \"./crypto\"\nimport {getTransactionCode, getScriptCode, defaultsByName} from \"./file\"\nimport {resolveImports, replaceImportAddresses} from \"./imports\"\nimport {getServiceAddress} from \"./manager\"\nimport {isObject} from \"./utils\"\n\nconst DEFAULT_LIMIT = 999\n\nexport const extractParameters = ixType => {\n  return async params => {\n    let ixCode, ixName, ixSigners, ixArgs, ixService, ixTransformers, ixLimit\n\n    if (isObject(params[0])) {\n      const [props] = params\n      const {\n        name,\n        code,\n        args,\n        signers,\n        transformers,\n        limit,\n        service = false,\n      } = props\n\n      ixService = service\n\n      if (!name && !code) {\n        throw Error(\n          \"Both `name` and `code` are missing. Provide either of them\"\n        )\n      }\n      ixName = name\n      ixCode = code\n\n      ixSigners = signers\n      ixArgs = args\n      ixTransformers = transformers || []\n      ixLimit = limit\n    } else {\n      if (ixType === \"script\") {\n        ;[ixName, ixArgs, ixLimit, ixTransformers] = params\n      } else {\n        ;[ixName, ixSigners, ixArgs, ixLimit, ixTransformers] = params\n      }\n    }\n\n    // Check that limit is always set\n    ixLimit = ixLimit || DEFAULT_LIMIT\n\n    if (ixName) {\n      const getIxTemplate =\n        ixType === \"script\" ? getScriptCode : getTransactionCode\n      ixCode = await getIxTemplate({name: ixName})\n    }\n\n    // We need a way around to allow initial scripts and transactions for Manager contract\n    let deployedContracts\n    if (ixService) {\n      deployedContracts = defaultsByName\n    } else {\n      deployedContracts = await resolveImports(ixCode)\n    }\n\n    const serviceAddress = await getServiceAddress()\n    const addressMap = {\n      ...defaultsByName,\n      ...deployedContracts,\n      FlowManager: serviceAddress,\n    }\n\n    ixCode = replaceImportAddresses(ixCode, addressMap)\n\n    // Apply all the necessary transformations to the code\n    for (const i in ixTransformers) {\n      const transformer = ixTransformers[i]\n      ixCode = await transformer(ixCode)\n    }\n\n    return {\n      code: ixCode,\n      signers: ixSigners,\n      args: ixArgs,\n      limit: ixLimit,\n    }\n  }\n}\n\n/**\n * Submits transaction to emulator network and waits before it will be sealed.\n * Returns transaction result.\n * @param {string} [props.name] - Name of Cadence template file\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {string} [props.code] - Cadence code of the transaction.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @param {[string]} [props.signers] - list of signers, who will authorize transaction, specified as array of addresses.\n * @returns {Promise<any>}\n */\n\nexport const sendTransaction = async (...props) => {\n  try {\n    const extractor = extractParameters(\"tx\")\n    const {code, args, signers, limit} = await extractor(props)\n\n    const serviceAuth = authorization()\n\n    // set repeating transaction code\n    const ix = [\n      fcl.transaction(code),\n      fcl.payer(serviceAuth),\n      fcl.proposer(serviceAuth),\n      fcl.limit(limit),\n    ]\n\n    // use signers if specified\n    if (signers) {\n      const auths = signers.map(address => authorization(address))\n      ix.push(fcl.authorizations(auths))\n    } else {\n      // and only service account if no signers\n      ix.push(fcl.authorizations([serviceAuth]))\n    }\n\n    // add arguments if any\n    if (args) {\n      const resolvedArgs = await resolveArguments(args, code)\n      ix.push(fcl.args(resolvedArgs))\n    }\n    const response = await fcl.send(ix)\n    const result = await fcl.tx(response).onceExecuted()\n\n    return [result, null]\n  } catch (e) {\n    return [null, e]\n  }\n}\n\n/**\n * Sends script code for execution. Returns decoded value\n * @param {string} props.code - Cadence code of the script to be submitted.\n * @param {string} props.name - name of the file to source code from.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @returns {Promise<*>}\n */\n\nexport const executeScript = async (...props) => {\n  try {\n    const extractor = extractParameters(\"script\")\n    const {code, args, limit} = await extractor(props)\n\n    const ix = [fcl.script(code), fcl.limit(limit)]\n    // add arguments if any\n    if (args) {\n      const resolvedArgs = await resolveArguments(args, code)\n      ix.push(fcl.args(resolvedArgs))\n    }\n    const response = await fcl.send(ix)\n    const result = await fcl.decode(response)\n    return [result, null]\n  } catch (e) {\n    return [null, e]\n  }\n}\n","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction (_ name: String, pubKey: String, manager: Address) {\r\n    prepare( admin: AuthAccount) {\r\n        let newAccount = AuthAccount(payer:admin)\r\n        newAccount.addPublicKey(pubKey.decodeHex())\r\n\r\n        let linkPath = FlowManager.accountManagerPath\r\n        let accountManager = getAccount(manager)\r\n                            .getCapability(linkPath)!\r\n                            .borrow<&FlowManager.Mapper>()!\r\n        \r\n        // Create a record in account database\r\n        let address = newAccount.address\r\n        accountManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for createAccount transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const createAccountTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `createAccount =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends createAccount transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const createAccount = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await createAccountTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `createAccount =>`);\n  reportMissing(\"signers\", signers.length, 1, `createAccount =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\r\n    prepare(acct: AuthAccount){\r\n        let decoded = code.decodeHex()\r\n        acct.contracts.add(\r\n           name: name,\r\n           code: decoded,\r\n           ##ARGS-LIST##\r\n        )\r\n\r\n        let linkPath = FlowManager.contractManagerPath\r\n        let contractManager = getAccount(manager)\r\n                    .getCapability(linkPath)!\r\n                    .borrow<&FlowManager.Mapper>()!\r\n\r\n        let address = acct.address\r\n        contractManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for deployContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const deployContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `deployContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends deployContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const deployContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await deployContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `deployContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `deployContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\ntransaction ( code: String ) {\r\n    prepare( admin: AuthAccount) {\r\n        admin.contracts.add(\r\n           name: \"FlowManager\",\r\n           code: code.decodeHex(),\r\n        )\r\n   }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for initManager transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const initManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `initManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends initManager transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const initManager = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await initManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `initManager =>`);\n  reportMissing(\"signers\", signers.length, 1, `initManager =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for mintTokens transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const mintTokensTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `mintTokens =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends mintTokens transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const mintTokens = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await mintTokensTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `mintTokens =>`);\n  reportMissing(\"signers\", signers.length, 1, `mintTokens =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction(name: String, address: Address) {\r\n    prepare(signer: AuthAccount){\r\n        let linkPath = FlowManager.contractManagerPath\r\n        let contractManager = signer\r\n                                .getCapability(linkPath)!\r\n                                .borrow<&FlowManager.Mapper>()!\r\n        contractManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for registerContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const registerContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `registerContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends registerContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const registerContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await registerContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `registerContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `registerContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\ntransaction{\r\n    prepare(acct: AuthAccount){\r\n        log(acct.address)\r\n    }\r\n}\n`;\n\n/**\n* Method to generate cadence code for scratch transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const scratchTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `scratch =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends scratch transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const scratch = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await scratchTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `scratch =>`);\n  reportMissing(\"signers\", signers.length, 1, `scratch =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(offset: UInt64){\n    prepare(signer:AuthAccount){\n        FlowManager.setBlockOffset(offset)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for setBlockOffset transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const setBlockOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `setBlockOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends setBlockOffset transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const setBlockOffset = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await setBlockOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `setBlockOffset =>`);\n  reportMissing(\"signers\", signers.length, 1, `setBlockOffset =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(offset: UFix64){\n    prepare(signer:AuthAccount){\n        FlowManager.setTimestampOffset(offset)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for setTimestampOffset transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const setTimestampOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `setTimestampOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends setTimestampOffset transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const setTimestampOffset = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await setTimestampOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `setTimestampOffset =>`);\n  reportMissing(\"signers\", signers.length, 1, `setTimestampOffset =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for updateContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const updateContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `updateContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends updateContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const updateContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await updateContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `updateContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `updateContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","import { createAccountTemplate, createAccount } from \"./createAccount\";\nimport { deployContractTemplate, deployContract } from \"./deployContract\";\nimport { initManagerTemplate, initManager } from \"./initManager\";\nimport { mintTokensTemplate, mintTokens } from \"./mintTokens\";\nimport { registerContractTemplate, registerContract } from \"./registerContract\";\nimport { scratchTemplate, scratch } from \"./scratch\";\nimport { setBlockOffsetTemplate, setBlockOffset } from \"./setBlockOffset\";\nimport { setTimestampOffsetTemplate, setTimestampOffset } from \"./setTimestampOffset\";\nimport { updateContractTemplate, updateContract } from \"./updateContract\";\n\nexport default {\n  createAccountTemplate,\n  createAccount,\n  deployContractTemplate,\n  deployContract,\n  initManagerTemplate,\n  initManager,\n  mintTokensTemplate,\n  mintTokens,\n  registerContractTemplate,\n  registerContract,\n  scratchTemplate,\n  scratch,\n  setBlockOffsetTemplate,\n  setBlockOffset,\n  setTimestampOffsetTemplate,\n  setTimestampOffset,\n  updateContractTemplate,\n  updateContract,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {sendTransaction} from \"./interaction\"\nimport {getServiceAddress} from \"./manager\"\nimport {defaultsByName, getContractCode} from \"./file\"\n\nimport txRegistry from \"./generated/transactions\"\nimport {isObject} from \"./utils\"\nimport {\n  extractContractParameters,\n  generateSchema,\n  splitArgs,\n} from \"@onflow/flow-cadut\"\nimport {replaceImportAddresses, resolveImports} from \"./imports\"\n\nconst {updateContractTemplate, deployContractTemplate} = txRegistry\n\nexport const hexContract = contract =>\n  Buffer.from(contract, \"utf8\").toString(\"hex\")\n\nconst extractParameters = async params => {\n  let ixName, ixTo, ixAddressMap, ixArgs, ixUpdate\n\n  if (isObject(params[0])) {\n    const [props] = params\n    const {name, to, addressMap, args, update} = props\n\n    if (!name) {\n      throw Error(\"'name' field is missing\")\n    }\n\n    ixName = name\n    ixTo = to\n    ixArgs = args\n    ixAddressMap = addressMap\n    ixUpdate = update\n  } else {\n    ;[ixName, ixTo, ixAddressMap, ixArgs, ixUpdate] = params\n  }\n\n  const serviceAddress = await getServiceAddress()\n  const addressMap = {\n    ...defaultsByName,\n    FlowManager: serviceAddress,\n    ...ixAddressMap,\n  }\n\n  return {\n    name: ixName,\n    to: ixTo,\n    args: ixArgs,\n    update: ixUpdate,\n    addressMap,\n  }\n}\n\n/**\n * Deploys a contract by name to specified account\n * Returns transaction result.\n * @param {string} props.to - If no address is supplied, the contract will be deployed to the emulator service account.\n * @param {string} props.name  - The name of the contract to look for. This should match a .cdc file located at the specified `basePath`.\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced.\n * @returns {Promise<any>}\n */\nexport const deployContractByName = async (...props) => {\n  const params = await extractParameters(props)\n  const {to, name, addressMap, args, update = false} = params\n\n  const resolvedAddress = to || (await getServiceAddress())\n  const contractCode = await getContractCode({name, addressMap})\n\n  const ixName = /[\\\\/]/.test(name) ? null : name\n\n  return deployContract({\n    to: resolvedAddress,\n    code: contractCode,\n    name: ixName,\n    args,\n    update,\n  })\n}\n\n/**\n * Deploys contract as Cadence code to specified account\n * Returns transaction result.\n * @param {string} props.code - Cadence code for contract to be deployed\n * @param {string} props.to - If no address is supplied, the contract\n * will be deployed to the emulator service account\n * @param {string} props.name  - The name of the contract to look for. This should match\n * a .cdc file located at the specified `basePath`\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced\n */\nexport const deployContract = async props => {\n  const {to, code: contractCode, name, args, update} = props\n\n  const params = await extractContractParameters(contractCode)\n  const ixName = name || params.contractName\n\n  // TODO: extract name from contract code\n  const containerAddress = to || (await getServiceAddress())\n  const managerAddress = await getServiceAddress()\n\n  // Replace import addresses, before hexing contract code\n  const deployedContracts = await resolveImports(contractCode)\n  const serviceAddress = await getServiceAddress()\n  const addressMap = {\n    ...defaultsByName,\n    ...deployedContracts,\n    FlowManager: serviceAddress,\n  }\n\n  const hexedCode = hexContract(\n    replaceImportAddresses(contractCode, addressMap)\n  )\n\n  let code = update\n    ? await updateContractTemplate(addressMap)\n    : await deployContractTemplate(addressMap)\n\n  let deployArgs = [ixName, hexedCode, managerAddress]\n\n  if (args) {\n    deployArgs = deployArgs.concat(args)\n    const schema = generateSchema(params.args).map(item => splitArgs(item)[0])\n\n    const argLetter = \"abcdefghijklmnopqrstuvwxyz\"\n    let argList = []\n    for (let i = 0; i < schema.length; i++) {\n      const value = schema[i]\n      argList.push(`${argLetter[i]}: ${value}`)\n    }\n\n    code = code.replace(\"##ARGS-WITH-TYPES##\", `, ${params.args}`)\n    code = code.replace(\"##ARGS-LIST##\", argList)\n  } else {\n    code = code.replace(\"##ARGS-WITH-TYPES##\", ``)\n    code = code.replace(\"##ARGS-LIST##\", \"\")\n  }\n\n  const signers = [containerAddress]\n\n  return sendTransaction({\n    code,\n    args: deployArgs,\n    signers,\n  })\n}\n","/** pragma type contract **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  deployContract,\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\npub contract FlowManager {\r\n\r\n    /// Account Manager\r\n    pub event AccountAdded(address: Address)\r\n\r\n    pub struct Mapper {\r\n        pub let accounts: {String: Address}\r\n\r\n        pub fun getAddress(_ name: String): Address? {\r\n            return self.accounts[name]\r\n        }\r\n\r\n        pub fun setAddress(_ name: String, address: Address){\r\n            self.accounts[name] = address\r\n            emit FlowManager.AccountAdded(address: address)\r\n        }\r\n\r\n        init(){\r\n            self.accounts = {}\r\n        }\r\n    }\r\n\r\n    pub fun getAccountAddress(_ name: String): Address?{\r\n        let accountManager = self.account\r\n            .getCapability(self.accountManagerPath)\r\n            .borrow<&FlowManager.Mapper>()!\r\n\r\n        return accountManager.getAddress(name)\r\n    }\r\n\r\n    pub let defaultAccounts: {Address : String}\r\n\r\n    pub fun resolveDefaultAccounts(_ address: Address): Address{\r\n        let alias = self.defaultAccounts[address]!\r\n        return self.getAccountAddress(alias)!\r\n    }\r\n\r\n    pub let accountManagerStorage: StoragePath\r\n    pub let contractManagerStorage: StoragePath\r\n    pub let accountManagerPath: PublicPath\r\n    pub let contractManagerPath: PublicPath\r\n\r\n    /// Environment Manager\r\n    pub event BlockOffsetChanged(offset: UInt64)\r\n    pub event TimestampOffsetChanged(offset: UFix64)\r\n\r\n    pub struct MockBlock {\r\n        pub let id: [UInt8; 32]\r\n        pub let height: UInt64\r\n        pub let view: UInt64\r\n        pub let timestamp: UFix64\r\n\r\n        init(_ id: [UInt8; 32], _ height: UInt64, _ view: UInt64, _ timestamp: UFix64){\r\n            self.id = id\r\n            self.height = height\r\n            self.view = view\r\n            self.timestamp = timestamp\r\n        }\r\n    }\r\n\r\n    pub fun setBlockOffset(_ offset: UInt64){\r\n        self.blockOffset = offset\r\n        emit FlowManager.BlockOffsetChanged(offset: offset)\r\n    }\r\n\r\n    pub fun setTimestampOffset(_ offset: UFix64){\r\n        self.timestampOffset = offset\r\n        emit FlowManager.TimestampOffsetChanged(offset: offset)\r\n    }\r\n\r\n    pub fun getBlockHeight(): UInt64 {\r\n        var block = getCurrentBlock()\r\n        return block.height + self.blockOffset\r\n    }\r\n\r\n    pub fun getBlockTimestamp(): UFix64 {\r\n        var block = getCurrentBlock()\r\n        return block.timestamp + self.timestampOffset\r\n    }\r\n\r\n    pub fun getBlock(): MockBlock {\r\n        var block =  getCurrentBlock()\r\n        let mockBlock = MockBlock(block.id, block.height, block.view, block.timestamp);\r\n        return mockBlock\r\n    }\r\n\r\n    pub var blockOffset: UInt64;\r\n    pub var timestampOffset: UFix64;\r\n\r\n\r\n    // Initialize contract\r\n    init(){\r\n        // Environment defaults\r\n        self.blockOffset = 0;\r\n        self.timestampOffset = 0.0;\r\n\r\n        // Account Manager initialization\r\n        let accountManager = Mapper()\r\n        let contractManager = Mapper()\r\n\r\n        self.defaultAccounts = {\r\n          0x01: \"Alice\",\r\n          0x02: \"Bob\",\r\n          0x03: \"Charlie\",\r\n          0x04: \"Dave\",\r\n          0x05: \"Eve\"\r\n        }\r\n\r\n        self.accountManagerStorage = /storage/testSuiteAccountManager\r\n        self.contractManagerStorage = /storage/testSuiteContractManager\r\n\r\n        self.accountManagerPath = /public/testSuiteAccountManager\r\n        self.contractManagerPath = /public/testSuiteContractManager\r\n        \r\n        // Destroy previously stored values\r\n        self.account.load<Mapper>(from: self.accountManagerStorage)\r\n        self.account.load<Mapper>(from: self.contractManagerStorage)\r\n\r\n        self.account.save(accountManager, to: self.accountManagerStorage)\r\n        self.account.save(contractManager, to: self.contractManagerStorage)\r\n\r\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\r\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\r\n    }\r\n}\r\n \n`;\n\n/**\n* Method to generate cadence code for FlowManager contract\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const FlowManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `FlowManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Deploys FlowManager transaction to the network\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> args - list of arguments\n* param Array<string> - list of signers\n*/\nexport const  deployFlowManager = async (props) => {\n  const { addressMap = {} } = props;\n  const code = await FlowManagerTemplate(addressMap);\n  const name = \"FlowManager\"\n\n  return deployContract({ code, name, processed: true, ...props })\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty, cause script will throw error if FlowManager is not\n    // added to service address\n}\n\n`;\n\n/**\n* Method to generate cadence code for checkManager script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const checkManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `checkManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const checkManager = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await checkManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `checkManager =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\npub fun main(name: String, managerAccount: Address):Address? {\r\n    let manager = getAccount(managerAccount)\r\n    let linkPath = FlowManager.accountManagerPath\r\n    let accountManager = manager\r\n                        .getCapability(linkPath)\r\n                        .borrow<&FlowManager.Mapper>()!\r\n\r\n    return accountManager.getAddress(name)\r\n\r\n}\n`;\n\n/**\n* Method to generate cadence code for getAccountAddress script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getAccountAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getAccountAddress =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getAccountAddress = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getAccountAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `getAccountAddress =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\n// This script reads the balance field of an account's FlowToken Balance\r\n\r\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\r\nimport ExampleToken from 0xTOKENADDRESS\r\n\r\npub fun main(account: Address): UFix64 {\r\n    let acct = getAccount(account)\r\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\r\n        ?? panic(\"Could not borrow Balance reference to the Vault\")\r\n\r\n    return vaultRef.balance\r\n}\n`;\n\n/**\n* Method to generate cadence code for getBalance script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getBalanceTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBalance =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBalance = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getBalanceTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `getBalance =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main():UInt64 {\n    return FlowManager.blockOffset\n}\n\n`;\n\n/**\n* Method to generate cadence code for getBlockOffset script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getBlockOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBlockOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBlockOffset = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getBlockOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `getBlockOffset =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\npub fun main(name: String, managerAccount: Address):Address? {\r\n    let manager = getAccount(managerAccount)\r\n    let linkPath = FlowManager.contractManagerPath\r\n    let contractManager = manager\r\n                        .getCapability(linkPath)\r\n                        .borrow<&FlowManager.Mapper>()!\r\n\r\n    return contractManager.getAddress(name)\r\n\r\n}\n`;\n\n/**\n* Method to generate cadence code for getContractAddress script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getContractAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getContractAddress =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getContractAddress = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getContractAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `getContractAddress =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main():UFix64 {\n    return FlowManager.timestampOffset\n}\n\n`;\n\n/**\n* Method to generate cadence code for getTimestampOffset script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getTimestampOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getTimestampOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getTimestampOffset = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getTimestampOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `getTimestampOffset =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","import { checkManagerTemplate, checkManager } from \"./checkManager\";\nimport { getAccountAddressTemplate, getAccountAddress } from \"./getAccountAddress\";\nimport { getBalanceTemplate, getBalance } from \"./getBalance\";\nimport { getBlockOffsetTemplate, getBlockOffset } from \"./getBlockOffset\";\nimport { getContractAddressTemplate, getContractAddress } from \"./getContractAddress\";\nimport { getManagerAddressTemplate, getManagerAddress } from \"./getManagerAddress\";\nimport { getTimestampOffsetTemplate, getTimestampOffset } from \"./getTimestampOffset\";\n\nexport default {\n  checkManagerTemplate,\n  checkManager,\n  getAccountAddressTemplate,\n  getAccountAddress,\n  getBalanceTemplate,\n  getBalance,\n  getBlockOffsetTemplate,\n  getBlockOffset,\n  getContractAddressTemplate,\n  getContractAddress,\n  getManagerAddressTemplate,\n  getManagerAddress,\n  getTimestampOffsetTemplate,\n  getTimestampOffset,\n};\n","import contracts from \"./contracts\";\nimport scripts from \"./scripts\";\nimport transactions from \"./transactions\";\n\nexport default {\n  contracts,\n  scripts,\n  transactions,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {config} from \"@onflow/config\"\nimport {withPrefix} from \"./address\"\nimport {hexContract} from \"./deploy-code\"\nimport registry from \"./generated\"\n\nexport const initManager = async () => {\n  const code = await registry.transactions.initManagerTemplate()\n  const contractCode = await registry.contracts.FlowManagerTemplate()\n  const hexedContract = hexContract(contractCode)\n  const args = [hexedContract]\n\n  await sendTransaction({\n    code,\n    args,\n    service: true,\n  })\n}\n\nexport const getServiceAddress = async () => {\n  return withPrefix(await config().get(\"SERVICE_ADDRESS\"))\n}\n\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress()\n\n  const addressMap = {\n    FlowManager: serviceAddress,\n  }\n\n  const code = await registry.scripts.checkManagerTemplate(addressMap)\n\n  let [result, e] = await executeScript({\n    code,\n    service: true,\n  })\n  if (e && result === null) {\n    await initManager()\n  }\n\n  return getServiceAddress()\n}\n\n// TODO: replace method above after Cadence will allow to get contracts list on PublicAccount\n/*\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress();\n\n  const code = `\n    pub fun main(address: Address):Bool {\n      return getAccount(address).contracts.get(\"FlowManager\") != null\n    }\n  `;\n  const result = await executeScript({ code, args: [serviceAddress] });\n\n  if (!result) {\n    await initManager();\n  }\n\n  return serviceAddress;\n};\n */\n\nexport const getBlockOffset = async () => {\n  const FlowManager = await getManagerAddress()\n  const code = await registry.scripts.getBlockOffsetTemplate({FlowManager})\n  return executeScript({code})\n}\n\nexport const setBlockOffset = async offset => {\n  const FlowManager = await getManagerAddress()\n\n  const args = [offset]\n  const code = await registry.transactions.setBlockOffsetTemplate({FlowManager})\n  const payer = [FlowManager]\n\n  return sendTransaction({code, args, payer})\n}\n\nexport const getTimestampOffset = async () => {\n  const FlowManager = await getManagerAddress()\n  const code = await registry.scripts.getTimestampOffsetTemplate({FlowManager})\n  return executeScript({code})\n}\n\nexport const setTimestampOffset = async offset => {\n  const FlowManager = await getManagerAddress()\n\n  const args = [offset]\n  const code = await registry.transactions.setTimestampOffsetTemplate({\n    FlowManager,\n  })\n  const payer = [FlowManager]\n\n  return sendTransaction({code, args, payer})\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getManagerAddress} from \"./manager\"\nimport {executeScript} from \"./interaction\"\nimport {defaultsByName} from \"./file\"\n\nimport registry from \"./generated\"\n\n/**\n * Returns address of the account where contract specified by name is currently deployed\n * @param {string} name - name of the account to look for\n * @param {boolean} [useDefaults=false] - whether we shall look into default addressed first\n * @returns {Promise<string>}\n */\nexport const getContractAddress = async (name, useDefaults = false) => {\n  // TODO: Maybe try to automatically deploy contract? \n\n  if (useDefaults) {\n    const defaultContract = defaultsByName[name]\n    if (defaultContract !== undefined) {\n      return defaultContract\n    }\n  }\n\n  const managerAddress = await getManagerAddress()\n  const addressMap = {FlowManager: managerAddress}\n\n  const code = await registry.scripts.getContractAddressTemplate(addressMap)\n  const args = [name, managerAddress]\n  const [contractAddress] = await executeScript({\n    code,\n    args,\n    service: true,\n  })\n\n  return contractAddress\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getContractAddress} from \"./contract\"\nimport {defaultsByName} from \"./file\"\n\nconst REGEXP_IMPORT = /(\\s*import\\s*)([\\w\\d]+)(\\s+from\\s*)([\\w\\d\".\\\\/]+)/g\n\nconst getPairs = line => {\n  return line\n    .split(/\\s/)\n    .map(item => item.replace(/\\s/g, \"\"))\n    .filter(item => item.length > 0 && item !== \"import\" && item !== \"from\")\n}\n\nconst collect = (acc, item) => {\n  const [contract, address] = item\n  acc[contract] = address\n  return acc\n}\n\n/**\n * Returns address map for contracts defined in template code.\n * @param {string} code - Cadence code to parse.\n * @returns {*}\n */\nexport const extractImports = code => {\n  if (!code || code.length === 0) {\n    return {}\n  }\n  return code\n    .split(\"\\n\")\n    .filter(line => line.includes(\"import\"))\n    .map(getPairs)\n    .reduce(collect, {})\n}\n\nexport const replaceImports = (code, addressMap) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract) => {\n    const newAddress =\n      addressMap instanceof Function\n        ? addressMap(contract)\n        : addressMap[contract]\n    return `${imp}${contract} from ${newAddress}`\n  })\n}\n\n/**\n * Returns Cadence template code with replaced import addresses\n * @param {string} code - Cadence template code.\n * @param {{string:string}} [addressMap={}] - name/address map or function to use as lookup table\n * for addresses in import statements.\n * @param byName - lag to indicate whether we shall use names of the contracts.\n * @returns {*}\n */\nexport const replaceImportAddresses = (code, addressMap, byName = true) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract, _, address) => {\n    const key = byName ? contract : address\n    const newAddress =\n      addressMap instanceof Function ? addressMap(key) : addressMap[key]\n    return `${imp}${contract} from ${newAddress}`\n  })\n}\n\n/**\n * Resolves import addresses defined in code template\n * @param {string} code - Cadence template code.\n * @returns {{string:string}} - name/address map\n */\nexport const resolveImports = async code => {\n  const addressMap = {}\n  const importList = extractImports(code)\n  for (const key in importList) {\n    if (defaultsByName[key]) {\n      addressMap[key] = defaultsByName[key]\n    } else {\n      const address = await getContractAddress(key)\n      addressMap[key] = address\n    }\n  }\n  return addressMap\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from \"fs\"\nimport path from \"path\"\nimport {config} from \"@onflow/config\"\n\nimport {replaceImportAddresses} from \"./imports\"\nimport {isObject} from \"./utils\"\n\nexport const readFile = path => {\n  return fs.readFileSync(path, \"utf8\")\n}\n\n/**\n * Address map with access by name for contracts deployed to emulator by default.\n * @type {{FlowFees: string, FlowToken: string, FungibleToken: string}}\n */\nexport const defaultsByName = {\n  FlowToken: \"0x0ae53cb6e3f42a79\",\n  FungibleToken: \"0xee82856bf20e2aa6\",\n  FlowFees: \"0xe5a8b7f23e8b548f\",\n  FlowStorageFees: \"0xf8d6e0586b0a20c7\",\n}\n\n/**\n * Address map with access by address for contracts deployed to emulator by default.\n * @type {{\"0xe5a8b7f23e8b548f\": string, \"0xf8d6e0586b0a20c7\": string, \"0xee82856bf20e2aa6\": string, \"0x0ae53cb6e3f42a79\": string}}\n */\nexport const defaultsByAddress = {\n  \"0xe5a8b7f23e8b548f\": \"0xe5a8b7f23e8b548f\", // FlowFees\n  \"0xf8d6e0586b0a20c7\": \"0xf8d6e0586b0a20c7\", // FlowStorageFees\n  \"0x0ae53cb6e3f42a79\": \"0x0ae53cb6e3f42a79\", // FlowToken\n  \"0xee82856bf20e2aa6\": \"0xee82856bf20e2aa6\", // FungibleToken\n}\n\nconst SCRIPT = \"scripts\"\nconst TRANSACTION = \"transactions\"\nconst CONTRACT = \"contracts\"\n\nexport const templateType = {\n  SCRIPT,\n  TRANSACTION,\n  CONTRACT,\n}\n\nexport const getPath = async (name, type = TRANSACTION) => {\n  const configBase = await config().get(\"BASE_PATH\")\n\n  // We can simply overwrite \"configBase\" variable, but I believe it's better to leave it unchanged\n  let basePath = configBase\n\n  // It's possible to pass a set of paths via object, so we need to check if that's the case\n  if (isObject(configBase)) {\n    const typePath = configBase[type]\n\n    // if there is a specific path for this type, then we shall resolve it\n    if (typePath) {\n      return path.resolve(typePath, `./${name}.cdc`)\n    }\n\n    // otherwise use \"base\" value\n    basePath = configBase.base\n  }\n\n  return path.resolve(basePath, `./${type}/${name}.cdc`)\n}\n\n/**\n * Returns Cadence template for specified file. Replaces imports using provided address map\n * @param file - name of the file to look for.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [byAddress=false] - flag to indicate if address map is address to address type.\n * @returns {string}\n */\nexport const getTemplate = (file, addressMap = {}, byAddress = false) => {\n  const rawCode = readFile(file)\n\n  const defaults = byAddress ? defaultsByAddress : defaultsByName\n\n  return addressMap\n    ? replaceImportAddresses(rawCode, {\n        ...defaults,\n        ...addressMap,\n      })\n    : rawCode\n}\n\n/**\n * Returns contract template using name of the file in \"contracts\" folder containing the code.\n * @param name - name of the contract template in \"contract\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getContractCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.CONTRACT)\n  return getTemplate(path, addressMap)\n}\n\n/**\n * Returns transaction template using name of the file in \"transactions\" folder containing the code.\n * @param name - name of the transaction template in \"transactions\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getTransactionCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.TRANSACTION)\n  return getTemplate(path, addressMap)\n}\n\n/**\n * Returns script template using name of the file in \"scripts\" folder containing the code.\n * @param name - name of the script template in \"scripts\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getScriptCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.SCRIPT)\n  return getTemplate(path, addressMap)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport registry from \"./generated\"\nimport {defaultsByName} from \"./file\"\n\nconst FlowTokenMap = {ExampleToken: defaultsByName.FlowToken}\n\nconst lowerFirst = name => {\n  return name[0].toLowerCase() + name.slice(1)\n}\n\nexport const makeMintTransaction = async name => {\n  const code = await registry.transactions.mintTokensTemplate(FlowTokenMap)\n  const pattern = /(ExampleToken)/gi\n\n  return code.replace(pattern, match => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name)\n  })\n}\n\nexport const makeGetBalance = async name => {\n  const code = await registry.scripts.getBalanceTemplate(FlowTokenMap)\n  const pattern = /(ExampleToken)/gi\n\n  return code.replace(pattern, match => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name)\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {defaultsByName} from \"./file\"\nimport {replaceImportAddresses} from \"./imports\"\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {makeGetBalance, makeMintTransaction} from \"./templates\"\n\n/**\n * Returns current FlowToken balance of account specified by address\n * @param {string} address - address of account to check\n * @returns {Promise<*>}\n */\nexport const getFlowBalance = async address => {\n  const raw = await makeGetBalance(\"FlowToken\")\n  const code = replaceImportAddresses(raw, defaultsByName)\n  const args = [address]\n\n  return executeScript({code, args})\n}\n\n/**\n * Sends transaction to mint specified amount of FlowToken and send it to recipient.\n * Returns result of the transaction.\n * @param {string} recipient - address of recipient account\n * @param {string} amount - amount to mint and send\n * @returns {Promise<*>}\n */\nexport const mintFlow = async (recipient, amount) => {\n  const raw = await makeMintTransaction(\"FlowToken\")\n  const code = replaceImportAddresses(raw, defaultsByName)\n  const args = [recipient, amount]\n  return sendTransaction({code, args})\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {pubFlowKey} from \"./crypto\"\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {getManagerAddress} from \"./manager\"\n\nimport registry from \"./generated\"\n\n/**\n * Returns address of account specified by name. If account with that name doesn't exist it will be created\n * and assigned provided name as alias\n * @param {string} accountName - name of the account\n * @returns {Promise<string|*>}\n */\nexport const getAccountAddress = async accountName => {\n  const name =\n    accountName ||\n    `deployment-account-${(Math.random() * Math.pow(10, 8)).toFixed(0)}`\n\n  const managerAddress = await getManagerAddress()\n\n  const addressMap = {\n    FlowManager: managerAddress,\n  }\n\n  let accountAddress\n\n  const code = await registry.scripts.getAccountAddressTemplate(addressMap)\n\n  const args = [name, managerAddress]\n\n  const [result] = await executeScript({\n    code,\n    args,\n    service: true,\n  })\n  accountAddress = result\n\n  if (accountAddress === null) {\n    const code = await registry.transactions.createAccountTemplate(addressMap)\n    const publicKey = await pubFlowKey()\n    const args = [name, publicKey, managerAddress]\n\n    const [result] = await sendTransaction({\n      code,\n      args,\n    })\n    const {events} = result\n    const event = events.find(event => event.type.includes(\"AccountAdded\"))\n    accountAddress = event.data.address\n  }\n  return accountAddress\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {expect} = global\n\n/**\n * Return Promise from passed interaction\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*>\n * */\nexport const promise = async ix => {\n  if (typeof ix === \"function\") {\n    return await ix()\n  }\n  return await ix\n}\n\n/**\n * Ensure transaction did not throw and sealed.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - transaction result\n * */\nexport const shallPass = async ix => {\n  const wrappedInteraction = promise(ix)\n\n  const response = await wrappedInteraction\n  const [result, error] = response\n\n  if (error) {\n    throw error\n  }\n\n  let resolvedStatus\n  let resolvedErrorMessage\n  if (Array.isArray(result)) {\n    const {status, errorMessage} = result\n    resolvedStatus = status\n    resolvedErrorMessage = errorMessage\n  } else {\n    const {status, errorMessage} = result\n    resolvedStatus = status\n    resolvedErrorMessage = errorMessage\n  }\n\n  await expect(resolvedStatus).toBe(4)\n  await expect(resolvedErrorMessage).toBe(\"\")\n\n  return response\n}\n\n/**\n * Ensure interaction did not throw and return result of it\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - result of interaction\n * */\nexport const shallResolve = async ix => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n  const [, error] = response\n  expect(error).toBe(null)\n\n  return response\n}\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @param {string | RegExp} [message] - Expected error message provided as either a string equality or regular expression\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallRevert = async (ix, message) => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n  const [result, error] = response\n\n  await expect(result).toBe(null)\n\n  if (message) {\n    const errorMessage = error\n      .toString()\n      .match(/^error: (panic)|(assertion failed): ([^\\r\\n]*)$/m)\n      ?.at(3)\n    if (message instanceof RegExp) {\n      await expect(errorMessage).toMatch(message)\n    } else {\n      await expect(errorMessage).toBe(message)\n    }\n  } else {\n    await expect(error).not.toBe(null)\n  }\n\n  return response\n}\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallThrow = async ix => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n\n  const [result, error] = response\n  await expect(result).toBe(null)\n  await expect(error).not.toBe(null)\n\n  return response\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getServiceAddress} from \"./manager\"\n\nexport const importManager = async () => {\n  const serviceAddress = await getServiceAddress()\n  return `import FlowManager from ${serviceAddress}`\n}\n\nexport const importExists = (contractName, code) => {\n  return new RegExp(`import\\\\s+${contractName}`).test(code)\n}\n\nexport const builtInMethods = async code => {\n  let injectedImports = code\n  if (!importExists(\"FlowManager\", code)) {\n    const imports = await importManager()\n    injectedImports = `\n      ${imports}\n      ${code}  \n  `\n  }\n  return injectedImports\n    .replace(/getCurrentBlock\\(\\).height/g, `FlowManager.getBlockHeight()`)\n    .replace(\n      /getCurrentBlock\\(\\).timestamp/g,\n      `FlowManager.getBlockTimestamp()`\n    )\n}\n\nconst addressToIndex = address => {\n  return parseInt(address) - 1\n}\n\nconst addressToAlias = accounts => address => accounts[addressToIndex(address)]\n\nexport const playgroundImport = accounts => async code => {\n  let injectedImports = code\n  if (!importExists(\"FlowManager\", code)) {\n    const imports = await importManager()\n    injectedImports = `\n      ${imports}\n      ${code}  \n  `\n  }\n  return injectedImports.replace(/(?:getAccount\\()(.+)(?:\\))/g, (match, g1) => {\n    const alias = addressToAlias(accounts)(g1)\n    if (!alias) {\n      return `getAccount(FlowManager.resolveDefaultAccounts(${g1}))`\n    }\n    return `getAccount(FlowManager.getAccountAddress(\"${alias}\"))`\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {send, build, getBlock, decode} from \"@onflow/fcl\"\nimport {config} from \"@onflow/config\"\nimport {getAvailablePorts} from \"./utils\"\n\nconst {spawn} = require(\"child_process\")\n\nconst DEFAULT_HTTP_PORT = 8080\nconst DEFAULT_GRPC_PORT = 3569\n\nconst print = {\n  log: console.log,\n  service: console.log,\n  info: console.log,\n  error: console.error,\n  warn: console.warn,\n}\n\n/** Class representing emulator */\nexport class Emulator {\n  /**\n   * Create an emulator.\n   */\n  constructor() {\n    this.initialized = false\n    this.logging = false\n    this.filters = []\n    this.logProcessor = item => item\n  }\n\n  /**\n   * Set logging flag.\n   * @param {boolean} logging - whether logs shall be printed\n   */\n  setLogging(logging) {\n    this.logging = logging\n  }\n\n  /**\n   * Log message with a specific type.\n   * @param {*} message - message to put into log output\n   * @param {\"log\"|\"error\"} type - type of the message to output\n   */\n  log(message, type = \"log\") {\n    if (this.logging !== false) {\n      print[type](message)\n    }\n  }\n\n  checkLevel(message, level) {\n    if (level === \"debug\") {\n      // We might need to find a better way for this, but this will do for now...\n      return message.includes(\"LOG\") ? \"log\" : level\n    }\n    return level\n  }\n\n  extractKeyValue(str) {\n    // TODO: add regexp check that it conforms to necessary pattern\n    const [key, value] = str.split(\"=\")\n    if (value.includes(\"LOG\")) {\n      return {key, value: value.replace(`\"\\x1b[1;34m`, `\"\\x1b[1[34m`)}\n    }\n    return {key, value}\n  }\n\n  fixJSON(msg) {\n    const splitted = msg.split(\"\\n\").filter(item => item !== \"\")\n    const reconstructed =\n      splitted.length > 1 ? `[${splitted.join(\",\")}]` : splitted[0]\n    return reconstructed\n  }\n\n  parseDataBuffer(data) {\n    const message = data.toString()\n    try {\n      if (message.includes(\"msg\")) {\n        return JSON.parse(this.fixJSON(message))\n      }\n    } catch (e) {\n      console.error(e)\n      return {msg: e, level: \"JSON Error\"}\n    }\n    return {msg: message, level: \"parser\"}\n  }\n\n  /**\n   * Start emulator.\n   * @param {number} port - port to use for accessApi\n   * @param {boolean} logging - whether logs shall be printed\n   * @returns Promise<*>\n   */\n  async start(options = {}) {\n    // populate emulator ports with available ports\n    ;[this.grpcPort, this.restPort, this.adminPort] = await getAvailablePorts(3)\n\n    // override ports if specified in options\n    this.grpcPort = options.grpcPort || this.grpcPort\n    this.restPort = options.restPort || this.restPort\n    this.adminPort = options.adminPort || this.adminPort\n\n    // Support deprecated start call using static port\n    if (arguments.length > 1 || typeof arguments[0] === \"number\") {\n      console.warn(`Calling emulator.start with the port argument is now deprecated in favour of dynamically selected ports and will be removed in future versions of flow-js-testing.\nPlease refrain from supplying this argument, as using it may cause unintended consequences.\nMore info: https://github.com/onflow/flow-js-testing/blob/master/TRANSITIONS.md#001-deprecate-emulatorstart-port-argument`)\n      ;[this.adminPort, options = {}] = arguments\n\n      const offset = this.adminPort - DEFAULT_HTTP_PORT\n      this.grpcPort = DEFAULT_GRPC_PORT + offset\n    }\n\n    const {flags = \"\", logging = false} = options\n\n    // config access node\n    config().put(\"accessNode.api\", `http://localhost:${this.restPort}`)\n\n    this.logging = logging\n    this.process = spawn(\"flow\", [\n      \"emulator\",\n      \"--verbose\",\n      `--log-format=JSON`,\n      `--rest-port=${this.restPort}`,\n      `--admin-port=${this.adminPort}`,\n      `--port=${this.grpcPort}`,\n      flags,\n    ])\n    this.logProcessor = item => item\n\n    // Suppress logger warning while waiting for emulator\n    await config().put(\"logger.level\", 0)\n\n    return new Promise((resolve, reject) => {\n      let internalId\n      const checkLiveness = async function () {\n        try {\n          await send(build([getBlock(false)])).then(decode)\n          clearInterval(internalId)\n\n          // Enable logger after emulator has come online\n          await config().put(\"logger.level\", 2)\n          this.initialized = true\n          resolve(true)\n        } catch (err) {} // eslint-disable-line no-unused-vars, no-empty\n      }\n      internalId = setInterval(checkLiveness, 100)\n\n      this.process.stdout.on(\"data\", buffer => {\n        const data = this.parseDataBuffer(buffer)\n        if (Array.isArray(data)) {\n          let filtered = []\n          if (this.filters.length > 0) {\n            filtered = data.filter(item => {\n              const level = this.checkLevel(item.msg, item.level)\n              return this.filters.includes(level)\n            })\n          }\n          for (let i = 0; i < filtered.length; i++) {\n            const item = data[i]\n            const {msg} = item\n            const level = this.checkLevel(msg, item.level)\n            this.log(`${level.toUpperCase()}: ${msg}`)\n          }\n        } else {\n          const {msg} = data\n          const level = this.checkLevel(msg, data.level)\n          if (this.filters.length > 0) {\n            if (this.filters.includes(level)) {\n              this.log(`${level.toUpperCase()}: ${msg}`)\n              // TODO: Fix this\n              // This is really hacky solution, which depends on specific phrasing\n              if (msg.includes(\"Starting\") && msg.includes(this.adminPort)) {\n                this.log(\"EMULATOR IS UP! Listening for events!\")\n              }\n            }\n          } else {\n            this.log(`${level.toUpperCase()}: ${msg}`)\n            if (data.msg.includes(\"Starting HTTP server\")) {\n              this.log(\"EMULATOR IS UP! Listening for events!\")\n            }\n          }\n        }\n      })\n\n      this.process.stderr.on(\"data\", buffer => {\n        const {message} = this.parseDataBuffer(buffer)\n        this.log(`EMULATOR ERROR: ${message}`, \"error\")\n        this.initialized = false\n        clearInterval(internalId)\n        reject()\n      })\n\n      this.process.on(\"close\", code => {\n        if (this.filters.includes(\"service\")) {\n          this.log(`EMULATOR: process exited with code ${code}`)\n        }\n        this.initialized = false\n        clearInterval(internalId)\n        resolve(false)\n      })\n    })\n  }\n\n  /**\n   * Clear all log filters.\n   * @returns void\n   **/\n  clearFilters() {\n    this.filters = []\n  }\n\n  /**\n   * Remove specific type of log filter.\n   * @param {(debug|info|warning)} type - type of message\n   * @returns void\n   **/\n  removeFilter(type) {\n    this.filters = this.filters.filter(item => item !== type)\n  }\n\n  /**\n   * Add log filter.\n   * @param {(debug|info|warning)} type type - type of message\n   * @returns void\n   **/\n  addFilter(type) {\n    if (!this.filters.includes(type)) {\n      this.filters.push(type)\n    }\n  }\n\n  /**\n   * Stop emulator.\n   * @returns Promise<*>\n   */\n  async stop() {\n    // eslint-disable-next-line no-undef\n    return new Promise(resolve => {\n      this.process.kill()\n      setTimeout(() => {\n        this.initialized = false\n        resolve(false)\n      }, 50)\n    })\n  }\n}\n\n/** Singleton instance */\nexport default new Emulator()\n"],"names":["get","scope","path","fallback","split","length","head","rest","_error","set","key","env","conf","value","flowConfig","config","put","getConfigValue","async","init","basePath","props","pkey","process","sansPrefix","address","replace","withPrefix","ec","EC","signWithKey","privateKey","msgHex","sig","keyFromPrivate","Buffer","from","sign","sha","SHA3","update","digest","hashMsgHex","r","toArrayLike","s","concat","toString","authorization","addr","keyId","account","serviceAddress","tempId","fcl","signingFunction","signature","data","message","isObject","arg","getAvailablePorts","count","Promise","resolve","reject","server","createServer","listen","port","close","err","extractParameters","ixType","ixCode","ixName","ixSigners","ixArgs","ixService","ixTransformers","ixLimit","deployedContracts","params","name","code","args","signers","transformers","limit","service","Error","getIxTemplate","getScriptCode","getTransactionCode","defaultsByName","resolveImports","getServiceAddress","addressMap","FlowManager","replaceImportAddresses","i","transformer","sendTransaction","extractor","serviceAuth","ix","transaction","payer","proposer","auths","map","push","authorizations","resolvedArgs","resolveArguments","response","send","tx","onceExecuted","e","executeScript","script","decode","CODE","createAccountTemplate","fullMap","getEnvironment","reportMissingImports","deployContractTemplate","initManagerTemplate","mintTokensTemplate","registerContractTemplate","scratchTemplate","setBlockOffsetTemplate","setTimestampOffsetTemplate","updateContractTemplate","createAccount","reportMissing","processed","mintTokens","registerContract","scratch","updateContract","txRegistry","hexContract","contract","deployContractByName","ixTo","ixAddressMap","ixUpdate","to","resolvedAddress","contractCode","getContractCode","test","deployContract","extractContractParameters","contractName","containerAddress","managerAddress","hexedCode","deployArgs","schema","generateSchema","item","splitArgs","argLetter","argList","transactions","getManagerAddress","registry","result","initManager","getBlockOffset","setBlockOffset","offset","getTimestampOffset","setTimestampOffset","getContractAddress","useDefaults","defaultContract","undefined","contractAddress","REGEXP_IMPORT","getPairs","line","filter","collect","acc","extractImports","includes","reduce","byName","match","imp","_","Function","importList","FlowToken","FungibleToken","FlowFees","FlowStorageFees","defaultsByAddress","getPath","type","configBase","typePath","base","getTemplate","file","byAddress","rawCode","fs","readFileSync","readFile","FlowTokenMap","ExampleToken","lowerFirst","toLowerCase","slice","getFlowBalance","raw","makeGetBalance","mintFlow","recipient","amount","makeMintTransaction","getAccountAddress","accountName","Math","random","pow","toFixed","accountAddress","publicKey","getPublic","rlp","encode","pubFlowKey","events","find","event","expect","global","promise","shallPass","wrappedInteraction","error","resolvedStatus","resolvedErrorMessage","Array","isArray","status","errorMessage","toBe","shallResolve","shallRevert","_error$toString$match","at","RegExp","toMatch","not","shallThrow","builtInMethods","injectedImports","importExists","importManager","spawn","require","print","log","console","info","warn","constructor","this","initialized","logging","filters","logProcessor","setLogging","checkLevel","level","extractKeyValue","str","fixJSON","msg","splitted","join","parseDataBuffer","JSON","parse","options","grpcPort","restPort","adminPort","arguments","flags","internalId","setInterval","build","getBlock","then","clearInterval","stdout","on","buffer","filtered","toUpperCase","stderr","clearFilters","removeFilter","addFilter","kill","setTimeout"],"mappings":"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"}
{"version":3,"file":"index.module.js","sources":["../src/config.js","../src/init.js","../src/address.js","../src/crypto.js","../src/utils.js","../src/interaction.js","../src/generated/transactions/createAccount.js","../src/generated/transactions/deployContract.js","../src/generated/transactions/initManager.js","../src/generated/transactions/mintTokens.js","../src/generated/transactions/registerContract.js","../src/generated/transactions/scratch.js","../src/generated/transactions/setBlockOffset.js","../src/generated/transactions/setTimestampOffset.js","../src/generated/transactions/updateContract.js","../src/generated/transactions/index.js","../src/deploy-code.js","../src/generated/contracts/FlowManager.js","../src/generated/scripts/checkManager.js","../src/generated/scripts/getAccountAddress.js","../src/generated/scripts/getBalance.js","../src/generated/scripts/getBlockOffset.js","../src/generated/scripts/getContractAddress.js","../src/generated/scripts/getTimestampOffset.js","../src/generated/scripts/index.js","../src/generated/index.js","../src/manager.js","../src/contract.js","../src/imports.js","../src/file.js","../src/templates.js","../src/flow-token.js","../src/account.js","../src/jest-asserts.js","../src/transformers.js","../src/emulator.js"],"sourcesContent":["/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {flowConfig} from \"@onflow/fcl-config\"\nimport {config} from \"@onflow/config\"\n\n/**\n * Get value from provided scope and path.\n * @param scope - scope value.\n * @param path - value path in config (flow.json) file.\n * @param fallback - fallback value.\n * @returns {*} - value at specified scope and path.\n */\nexport const get = (scope, path, fallback) => {\n  if (typeof path === \"string\") return get(scope, path.split(\"/\"), fallback)\n  if (!path.length) return scope\n  try {\n    const [head, ...rest] = path\n    return get(scope[head], rest, fallback)\n  } catch (_error) {\n    return fallback\n  }\n}\n\n/**\n * Set globally available config value.\n * @param {string} key - key to be used to access stored value.\n * @param {string} env - value key in the environment (for example .env file).\n * @param {string} conf - value path in config (flow.json) file.\n * @param fallback - fallback value to be used if env and conf are absent.\n */\nexport const set = (key, env, conf, fallback) => {\n  let value = get(flowConfig(), conf, fallback)\n  if (!value) {\n    value = fallback\n  }\n  config().put(key, value)\n}\n\n/**\n * Returns config value at specified key.\n * @param key - key to the value.\n * @returns {Promise<*>} - value at specified key.\n */\nexport const getConfigValue = async key => {\n  return config().get(key)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {set} from \"./config\"\n\n/**\n * Inits framework variables, storing private key of service account and base path\n * where Cadence files are stored.\n * @param {string} basePath - path to the folder with Cadence files to be tested.\n * @param {number} [props.port] - port to use for accessAPI\n * @param {number} [props.pkey] - private key to use for service account in case of collisions\n */\nexport const init = async (basePath, props = {}) => {\n  const {\n    pkey = \"48a1f554aeebf6bf9fe0d7b5b79d080700b073ee77909973ea0b2f6fbc902\",\n  } = props\n\n  set(\"PRIVATE_KEY\", process.env.PK, \"accounts/emulator-account/key\", pkey)\n  set(\n    \"SERVICE_ADDRESS\",\n    process.env.SERVICE_ADDRESS,\n    \"accounts/emulator-account/address\",\n    \"f8d6e0586b0a20c7\"\n  )\n  set(\"BASE_PATH\", process.env.BASE_PATH, \"testing/paths\", basePath)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const sansPrefix = address => {\n  if (address == null) return null\n  return address.replace(/^0x/, \"\")\n}\n\nexport const withPrefix = address => {\n  if (address == null) return null\n  return \"0x\" + sansPrefix(address)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ec as EC} from \"elliptic\"\nimport {SHA3} from \"sha3\"\nimport * as fcl from \"@onflow/fcl\"\nimport * as rlp from \"rlp\"\nimport {config} from \"@onflow/config\"\nimport {sansPrefix, withPrefix} from \"./address\"\nconst ec = new EC(\"p256\")\n\nconst hashMsgHex = msgHex => {\n  const sha = new SHA3(256)\n  sha.update(Buffer.from(msgHex, \"hex\"))\n  return sha.digest()\n}\n\nexport const signWithKey = (privateKey, msgHex) => {\n  const key = ec.keyFromPrivate(Buffer.from(privateKey, \"hex\"))\n  const sig = key.sign(hashMsgHex(msgHex))\n  const n = 32 // half of signature length?\n  const r = sig.r.toArrayLike(Buffer, \"be\", n)\n  const s = sig.s.toArrayLike(Buffer, \"be\", n)\n  return Buffer.concat([r, s]).toString(\"hex\")\n}\n\nexport const authorization =\n  (addr, keyId = 0) =>\n  async (account = {}) => {\n    const serviceAddress = await config().get(\"SERVICE_ADDRESS\")\n    const pkey = await config().get(\"PRIVATE_KEY\")\n\n    addr = sansPrefix(addr || serviceAddress)\n\n    const signingFunction = async data => ({\n      keyId,\n      addr: withPrefix(addr),\n      signature: signWithKey(pkey, data.message),\n    })\n\n    return {\n      ...account,\n      tempId: `${addr}-${keyId}`,\n      addr: fcl.sansPrefix(addr),\n      keyId,\n      signingFunction,\n    }\n  }\n\nexport const pubFlowKey = async () => {\n  const keys = ec.keyFromPrivate(\n    Buffer.from(await config().get(\"PRIVATE_KEY\"), \"hex\")\n  )\n  const publicKey = keys.getPublic(\"hex\").replace(/^04/, \"\")\n  return rlp\n    .encode([\n      Buffer.from(publicKey, \"hex\"), // publicKey hex to binary\n      2, // P256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      3, // SHA3-256 per https://github.com/onflow/flow/blob/master/docs/accounts-and-keys.md#supported-signature--hash-algorithms\n      1000, // give key full weight\n    ])\n    .toString(\"hex\")\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {createServer} from \"net\"\n\nexport const isObject = arg => typeof arg === \"object\" && arg !== null\n\nexport function getAvailablePorts(count = 1) {\n  if (count === 0) return Promise.resolve([])\n  return new Promise((resolve, reject) => {\n    const server = createServer()\n    server.listen(0, () => {\n      const port = server.address().port\n      server.close(async err => {\n        if (err) reject(err)\n        resolve([...(await getAvailablePorts(count - 1)), port])\n      })\n    })\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fcl from \"@onflow/fcl\"\nimport {resolveArguments} from \"@onflow/flow-cadut\"\nimport {authorization} from \"./crypto\"\nimport {getTransactionCode, getScriptCode, defaultsByName} from \"./file\"\nimport {resolveImports, replaceImportAddresses} from \"./imports\"\nimport {getServiceAddress} from \"./manager\"\nimport {isObject} from \"./utils\"\n\nconst DEFAULT_LIMIT = 999\n\nexport const extractParameters = ixType => {\n  return async params => {\n    let ixCode, ixName, ixSigners, ixArgs, ixService, ixTransformers, ixLimit\n\n    if (isObject(params[0])) {\n      const [props] = params\n      const {\n        name,\n        code,\n        args,\n        signers,\n        transformers,\n        limit,\n        service = false,\n      } = props\n\n      ixService = service\n\n      if (!name && !code) {\n        throw Error(\n          \"Both `name` and `code` are missing. Provide either of them\"\n        )\n      }\n      ixName = name\n      ixCode = code\n\n      ixSigners = signers\n      ixArgs = args\n      ixTransformers = transformers || []\n      ixLimit = limit\n    } else {\n      if (ixType === \"script\") {\n        ;[ixName, ixArgs, ixLimit, ixTransformers] = params\n      } else {\n        ;[ixName, ixSigners, ixArgs, ixLimit, ixTransformers] = params\n      }\n    }\n\n    // Check that limit is always set\n    ixLimit = ixLimit || DEFAULT_LIMIT\n\n    if (ixName) {\n      const getIxTemplate =\n        ixType === \"script\" ? getScriptCode : getTransactionCode\n      ixCode = await getIxTemplate({name: ixName})\n    }\n\n    // We need a way around to allow initial scripts and transactions for Manager contract\n    let deployedContracts\n    if (ixService) {\n      deployedContracts = defaultsByName\n    } else {\n      deployedContracts = await resolveImports(ixCode)\n    }\n\n    const serviceAddress = await getServiceAddress()\n    const addressMap = {\n      ...defaultsByName,\n      ...deployedContracts,\n      FlowManager: serviceAddress,\n    }\n\n    ixCode = replaceImportAddresses(ixCode, addressMap)\n\n    // Apply all the necessary transformations to the code\n    for (const i in ixTransformers) {\n      const transformer = ixTransformers[i]\n      ixCode = await transformer(ixCode)\n    }\n\n    return {\n      code: ixCode,\n      signers: ixSigners,\n      args: ixArgs,\n      limit: ixLimit,\n    }\n  }\n}\n\n/**\n * Submits transaction to emulator network and waits before it will be sealed.\n * Returns transaction result.\n * @param {string} [props.name] - Name of Cadence template file\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {string} [props.code] - Cadence code of the transaction.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @param {[string]} [props.signers] - list of signers, who will authorize transaction, specified as array of addresses.\n * @returns {Promise<any>}\n */\n\nexport const sendTransaction = async (...props) => {\n  try {\n    const extractor = extractParameters(\"tx\")\n    const {code, args, signers, limit} = await extractor(props)\n\n    const serviceAuth = authorization()\n\n    // set repeating transaction code\n    const ix = [\n      fcl.transaction(code),\n      fcl.payer(serviceAuth),\n      fcl.proposer(serviceAuth),\n      fcl.limit(limit),\n    ]\n\n    // use signers if specified\n    if (signers) {\n      const auths = signers.map(address => authorization(address))\n      ix.push(fcl.authorizations(auths))\n    } else {\n      // and only service account if no signers\n      ix.push(fcl.authorizations([serviceAuth]))\n    }\n\n    // add arguments if any\n    if (args) {\n      const resolvedArgs = await resolveArguments(args, code)\n      ix.push(fcl.args(resolvedArgs))\n    }\n    const response = await fcl.send(ix)\n    const result = await fcl.tx(response).onceExecuted()\n\n    return [result, null]\n  } catch (e) {\n    return [null, e]\n  }\n}\n\n/**\n * Sends script code for execution. Returns decoded value\n * @param {string} props.code - Cadence code of the script to be submitted.\n * @param {string} props.name - name of the file to source code from.\n * @param {[any]} props.args - array of arguments specified as tupple, where last value is the type of preceding values.\n * @returns {Promise<*>}\n */\n\nexport const executeScript = async (...props) => {\n  try {\n    const extractor = extractParameters(\"script\")\n    const {code, args, limit} = await extractor(props)\n\n    const ix = [fcl.script(code), fcl.limit(limit)]\n    // add arguments if any\n    if (args) {\n      const resolvedArgs = await resolveArguments(args, code)\n      ix.push(fcl.args(resolvedArgs))\n    }\n    const response = await fcl.send(ix)\n    const result = await fcl.decode(response)\n    return [result, null]\n  } catch (e) {\n    return [null, e]\n  }\n}\n","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction (_ name: String, pubKey: String, manager: Address) {\r\n    prepare( admin: AuthAccount) {\r\n        let newAccount = AuthAccount(payer:admin)\r\n        newAccount.addPublicKey(pubKey.decodeHex())\r\n\r\n        let linkPath = FlowManager.accountManagerPath\r\n        let accountManager = getAccount(manager)\r\n                            .getCapability(linkPath)!\r\n                            .borrow<&FlowManager.Mapper>()!\r\n        \r\n        // Create a record in account database\r\n        let address = newAccount.address\r\n        accountManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for createAccount transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const createAccountTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `createAccount =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends createAccount transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const createAccount = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await createAccountTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `createAccount =>`);\n  reportMissing(\"signers\", signers.length, 1, `createAccount =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\r\n    prepare(acct: AuthAccount){\r\n        let decoded = code.decodeHex()\r\n        acct.contracts.add(\r\n           name: name,\r\n           code: decoded,\r\n           ##ARGS-LIST##\r\n        )\r\n\r\n        let linkPath = FlowManager.contractManagerPath\r\n        let contractManager = getAccount(manager)\r\n                    .getCapability(linkPath)!\r\n                    .borrow<&FlowManager.Mapper>()!\r\n\r\n        let address = acct.address\r\n        contractManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for deployContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const deployContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `deployContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends deployContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const deployContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await deployContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `deployContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `deployContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\ntransaction ( code: String ) {\r\n    prepare( admin: AuthAccount) {\r\n        admin.contracts.add(\r\n           name: \"FlowManager\",\r\n           code: code.decodeHex(),\r\n        )\r\n   }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for initManager transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const initManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `initManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends initManager transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const initManager = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await initManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `initManager =>`);\n  reportMissing(\"signers\", signers.length, 1, `initManager =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic(\"Signer is not the token admin\")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic(\"Unable to borrow receiver reference\")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for mintTokens transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const mintTokensTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `mintTokens =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends mintTokens transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const mintTokens = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await mintTokensTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `mintTokens =>`);\n  reportMissing(\"signers\", signers.length, 1, `mintTokens =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\ntransaction(name: String, address: Address) {\r\n    prepare(signer: AuthAccount){\r\n        let linkPath = FlowManager.contractManagerPath\r\n        let contractManager = signer\r\n                                .getCapability(linkPath)!\r\n                                .borrow<&FlowManager.Mapper>()!\r\n        contractManager.setAddress(name, address: address)\r\n    }\r\n}\r\n\n`;\n\n/**\n* Method to generate cadence code for registerContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const registerContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `registerContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends registerContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const registerContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await registerContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `registerContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `registerContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\ntransaction{\r\n    prepare(acct: AuthAccount){\r\n        log(acct.address)\r\n    }\r\n}\n`;\n\n/**\n* Method to generate cadence code for scratch transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const scratchTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `scratch =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends scratch transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const scratch = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await scratchTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `scratch =>`);\n  reportMissing(\"signers\", signers.length, 1, `scratch =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(offset: UInt64){\n    prepare(signer:AuthAccount){\n        FlowManager.setBlockOffset(offset)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for setBlockOffset transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const setBlockOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `setBlockOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends setBlockOffset transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const setBlockOffset = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await setBlockOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `setBlockOffset =>`);\n  reportMissing(\"signers\", signers.length, 1, `setBlockOffset =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(offset: UFix64){\n    prepare(signer:AuthAccount){\n        FlowManager.setTimestampOffset(offset)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for setTimestampOffset transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const setTimestampOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `setTimestampOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends setTimestampOffset transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const setTimestampOffset = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await setTimestampOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `setTimestampOffset =>`);\n  reportMissing(\"signers\", signers.length, 1, `setTimestampOffset =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","/** pragma type transaction **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  sendTransaction\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n`;\n\n/**\n* Method to generate cadence code for updateContract transaction\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const updateContractTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `updateContract =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Sends updateContract transaction to the network\n* @param {Object.<string, string>} props.addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> props.args - list of arguments\n* @param Array<*> props.signers - list of signers\n*/\nexport const updateContract = async (props = {}) => {\n  const { addressMap, args = [], signers = [] } = props;\n  const code = await updateContractTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 3, `updateContract =>`);\n  reportMissing(\"signers\", signers.length, 1, `updateContract =>`);\n\n  return sendTransaction({code, processed: true, ...props})\n}","import { createAccountTemplate, createAccount } from \"./createAccount\";\nimport { deployContractTemplate, deployContract } from \"./deployContract\";\nimport { initManagerTemplate, initManager } from \"./initManager\";\nimport { mintTokensTemplate, mintTokens } from \"./mintTokens\";\nimport { registerContractTemplate, registerContract } from \"./registerContract\";\nimport { scratchTemplate, scratch } from \"./scratch\";\nimport { setBlockOffsetTemplate, setBlockOffset } from \"./setBlockOffset\";\nimport { setTimestampOffsetTemplate, setTimestampOffset } from \"./setTimestampOffset\";\nimport { updateContractTemplate, updateContract } from \"./updateContract\";\n\nexport default {\n  createAccountTemplate,\n  createAccount,\n  deployContractTemplate,\n  deployContract,\n  initManagerTemplate,\n  initManager,\n  mintTokensTemplate,\n  mintTokens,\n  registerContractTemplate,\n  registerContract,\n  scratchTemplate,\n  scratch,\n  setBlockOffsetTemplate,\n  setBlockOffset,\n  setTimestampOffsetTemplate,\n  setTimestampOffset,\n  updateContractTemplate,\n  updateContract,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {sendTransaction} from \"./interaction\"\nimport {getServiceAddress} from \"./manager\"\nimport {defaultsByName, getContractCode} from \"./file\"\n\nimport txRegistry from \"./generated/transactions\"\nimport {isObject} from \"./utils\"\nimport {\n  extractContractParameters,\n  generateSchema,\n  splitArgs,\n} from \"@onflow/flow-cadut\"\nimport {replaceImportAddresses, resolveImports} from \"./imports\"\n\nconst {updateContractTemplate, deployContractTemplate} = txRegistry\n\nexport const hexContract = contract =>\n  Buffer.from(contract, \"utf8\").toString(\"hex\")\n\nconst extractParameters = async params => {\n  let ixName, ixTo, ixAddressMap, ixArgs, ixUpdate\n\n  if (isObject(params[0])) {\n    const [props] = params\n    const {name, to, addressMap, args, update} = props\n\n    if (!name) {\n      throw Error(\"'name' field is missing\")\n    }\n\n    ixName = name\n    ixTo = to\n    ixArgs = args\n    ixAddressMap = addressMap\n    ixUpdate = update\n  } else {\n    ;[ixName, ixTo, ixAddressMap, ixArgs, ixUpdate] = params\n  }\n\n  const serviceAddress = await getServiceAddress()\n  const addressMap = {\n    ...defaultsByName,\n    FlowManager: serviceAddress,\n    ...ixAddressMap,\n  }\n\n  return {\n    name: ixName,\n    to: ixTo,\n    args: ixArgs,\n    update: ixUpdate,\n    addressMap,\n  }\n}\n\n/**\n * Deploys a contract by name to specified account\n * Returns transaction result.\n * @param {string} props.to - If no address is supplied, the contract will be deployed to the emulator service account.\n * @param {string} props.name  - The name of the contract to look for. This should match a .cdc file located at the specified `basePath`.\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced.\n * @returns {Promise<any>}\n */\nexport const deployContractByName = async (...props) => {\n  const params = await extractParameters(props)\n  const {to, name, addressMap, args, update = false} = params\n\n  const resolvedAddress = to || (await getServiceAddress())\n  const contractCode = await getContractCode({name, addressMap})\n\n  const ixName = /[\\\\/]/.test(name) ? null : name\n\n  return deployContract({\n    to: resolvedAddress,\n    code: contractCode,\n    name: ixName,\n    args,\n    update,\n  })\n}\n\n/**\n * Deploys contract as Cadence code to specified account\n * Returns transaction result.\n * @param {string} props.code - Cadence code for contract to be deployed\n * @param {string} props.to - If no address is supplied, the contract\n * will be deployed to the emulator service account\n * @param {string} props.name  - The name of the contract to look for. This should match\n * a .cdc file located at the specified `basePath`\n * @param {{string:string}} [props.addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [props.update=false] - flag to indicate whether the contract shall be replaced\n */\nexport const deployContract = async props => {\n  const {to, code: contractCode, name, args, update} = props\n\n  const params = await extractContractParameters(contractCode)\n  const ixName = name || params.contractName\n\n  // TODO: extract name from contract code\n  const containerAddress = to || (await getServiceAddress())\n  const managerAddress = await getServiceAddress()\n\n  // Replace import addresses, before hexing contract code\n  const deployedContracts = await resolveImports(contractCode)\n  const serviceAddress = await getServiceAddress()\n  const addressMap = {\n    ...defaultsByName,\n    ...deployedContracts,\n    FlowManager: serviceAddress,\n  }\n\n  const hexedCode = hexContract(\n    replaceImportAddresses(contractCode, addressMap)\n  )\n\n  let code = update\n    ? await updateContractTemplate(addressMap)\n    : await deployContractTemplate(addressMap)\n\n  let deployArgs = [ixName, hexedCode, managerAddress]\n\n  if (args) {\n    deployArgs = deployArgs.concat(args)\n    const schema = generateSchema(params.args).map(item => splitArgs(item)[0])\n\n    const argLetter = \"abcdefghijklmnopqrstuvwxyz\"\n    let argList = []\n    for (let i = 0; i < schema.length; i++) {\n      const value = schema[i]\n      argList.push(`${argLetter[i]}: ${value}`)\n    }\n\n    code = code.replace(\"##ARGS-WITH-TYPES##\", `, ${params.args}`)\n    code = code.replace(\"##ARGS-LIST##\", argList)\n  } else {\n    code = code.replace(\"##ARGS-WITH-TYPES##\", ``)\n    code = code.replace(\"##ARGS-LIST##\", \"\")\n  }\n\n  const signers = [containerAddress]\n\n  return sendTransaction({\n    code,\n    args: deployArgs,\n    signers,\n  })\n}\n","/** pragma type contract **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  deployContract,\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\npub contract FlowManager {\r\n\r\n    /// Account Manager\r\n    pub event AccountAdded(address: Address)\r\n\r\n    pub struct Mapper {\r\n        pub let accounts: {String: Address}\r\n\r\n        pub fun getAddress(_ name: String): Address? {\r\n            return self.accounts[name]\r\n        }\r\n\r\n        pub fun setAddress(_ name: String, address: Address){\r\n            self.accounts[name] = address\r\n            emit FlowManager.AccountAdded(address: address)\r\n        }\r\n\r\n        init(){\r\n            self.accounts = {}\r\n        }\r\n    }\r\n\r\n    pub fun getAccountAddress(_ name: String): Address?{\r\n        let accountManager = self.account\r\n            .getCapability(self.accountManagerPath)\r\n            .borrow<&FlowManager.Mapper>()!\r\n\r\n        return accountManager.getAddress(name)\r\n    }\r\n\r\n    pub let defaultAccounts: {Address : String}\r\n\r\n    pub fun resolveDefaultAccounts(_ address: Address): Address{\r\n        let alias = self.defaultAccounts[address]!\r\n        return self.getAccountAddress(alias)!\r\n    }\r\n\r\n    pub let accountManagerStorage: StoragePath\r\n    pub let contractManagerStorage: StoragePath\r\n    pub let accountManagerPath: PublicPath\r\n    pub let contractManagerPath: PublicPath\r\n\r\n    /// Environment Manager\r\n    pub event BlockOffsetChanged(offset: UInt64)\r\n    pub event TimestampOffsetChanged(offset: UFix64)\r\n\r\n    pub struct MockBlock {\r\n        pub let id: [UInt8; 32]\r\n        pub let height: UInt64\r\n        pub let view: UInt64\r\n        pub let timestamp: UFix64\r\n\r\n        init(_ id: [UInt8; 32], _ height: UInt64, _ view: UInt64, _ timestamp: UFix64){\r\n            self.id = id\r\n            self.height = height\r\n            self.view = view\r\n            self.timestamp = timestamp\r\n        }\r\n    }\r\n\r\n    pub fun setBlockOffset(_ offset: UInt64){\r\n        self.blockOffset = offset\r\n        emit FlowManager.BlockOffsetChanged(offset: offset)\r\n    }\r\n\r\n    pub fun setTimestampOffset(_ offset: UFix64){\r\n        self.timestampOffset = offset\r\n        emit FlowManager.TimestampOffsetChanged(offset: offset)\r\n    }\r\n\r\n    pub fun getBlockHeight(): UInt64 {\r\n        var block = getCurrentBlock()\r\n        return block.height + self.blockOffset\r\n    }\r\n\r\n    pub fun getBlockTimestamp(): UFix64 {\r\n        var block = getCurrentBlock()\r\n        return block.timestamp + self.timestampOffset\r\n    }\r\n\r\n    pub fun getBlock(): MockBlock {\r\n        var block =  getCurrentBlock()\r\n        let mockBlock = MockBlock(block.id, block.height, block.view, block.timestamp);\r\n        return mockBlock\r\n    }\r\n\r\n    pub var blockOffset: UInt64;\r\n    pub var timestampOffset: UFix64;\r\n\r\n\r\n    // Initialize contract\r\n    init(){\r\n        // Environment defaults\r\n        self.blockOffset = 0;\r\n        self.timestampOffset = 0.0;\r\n\r\n        // Account Manager initialization\r\n        let accountManager = Mapper()\r\n        let contractManager = Mapper()\r\n\r\n        self.defaultAccounts = {\r\n          0x01: \"Alice\",\r\n          0x02: \"Bob\",\r\n          0x03: \"Charlie\",\r\n          0x04: \"Dave\",\r\n          0x05: \"Eve\"\r\n        }\r\n\r\n        self.accountManagerStorage = /storage/testSuiteAccountManager\r\n        self.contractManagerStorage = /storage/testSuiteContractManager\r\n\r\n        self.accountManagerPath = /public/testSuiteAccountManager\r\n        self.contractManagerPath = /public/testSuiteContractManager\r\n        \r\n        // Destroy previously stored values\r\n        self.account.load<Mapper>(from: self.accountManagerStorage)\r\n        self.account.load<Mapper>(from: self.contractManagerStorage)\r\n\r\n        self.account.save(accountManager, to: self.accountManagerStorage)\r\n        self.account.save(contractManager, to: self.contractManagerStorage)\r\n\r\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\r\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\r\n    }\r\n}\r\n \n`;\n\n/**\n* Method to generate cadence code for FlowManager contract\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const FlowManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `FlowManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\n\n/**\n* Deploys FlowManager transaction to the network\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n* @param Array<*> args - list of arguments\n* param Array<string> - list of signers\n*/\nexport const  deployFlowManager = async (props) => {\n  const { addressMap = {} } = props;\n  const code = await FlowManagerTemplate(addressMap);\n  const name = \"FlowManager\"\n\n  return deployContract({ code, name, processed: true, ...props })\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty, cause script will throw error if FlowManager is not\n    // added to service address\n}\n\n`;\n\n/**\n* Method to generate cadence code for checkManager script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const checkManagerTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `checkManager =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const checkManager = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await checkManagerTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `checkManager =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\npub fun main(name: String, managerAccount: Address):Address? {\r\n    let manager = getAccount(managerAccount)\r\n    let linkPath = FlowManager.accountManagerPath\r\n    let accountManager = manager\r\n                        .getCapability(linkPath)\r\n                        .borrow<&FlowManager.Mapper>()!\r\n\r\n    return accountManager.getAddress(name)\r\n\r\n}\n`;\n\n/**\n* Method to generate cadence code for getAccountAddress script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getAccountAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getAccountAddress =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getAccountAddress = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getAccountAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `getAccountAddress =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\n// This script reads the balance field of an account's FlowToken Balance\r\n\r\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\r\nimport ExampleToken from 0xTOKENADDRESS\r\n\r\npub fun main(account: Address): UFix64 {\r\n    let acct = getAccount(account)\r\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\r\n        ?? panic(\"Could not borrow Balance reference to the Vault\")\r\n\r\n    return vaultRef.balance\r\n}\n`;\n\n/**\n* Method to generate cadence code for getBalance script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getBalanceTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBalance =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBalance = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getBalanceTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 1, `getBalance =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main():UInt64 {\n    return FlowManager.blockOffset\n}\n\n`;\n\n/**\n* Method to generate cadence code for getBlockOffset script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getBlockOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getBlockOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getBlockOffset = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getBlockOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `getBlockOffset =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\r\n\r\npub fun main(name: String, managerAccount: Address):Address? {\r\n    let manager = getAccount(managerAccount)\r\n    let linkPath = FlowManager.contractManagerPath\r\n    let contractManager = manager\r\n                        .getCapability(linkPath)\r\n                        .borrow<&FlowManager.Mapper>()!\r\n\r\n    return contractManager.getAddress(name)\r\n\r\n}\n`;\n\n/**\n* Method to generate cadence code for getContractAddress script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getContractAddressTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getContractAddress =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getContractAddress = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getContractAddressTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 2, `getContractAddress =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","/** pragma type script **/\n\nimport {\n  getEnvironment,\n  replaceImportAddresses,\n  reportMissingImports,\n  reportMissing,\n  executeScript\n} from '@onflow/flow-cadut'\n\nexport const CODE = `\nimport FlowManager from 0x01\n\npub fun main():UFix64 {\n    return FlowManager.timestampOffset\n}\n\n`;\n\n/**\n* Method to generate cadence code for getTimestampOffset script\n* @param {Object.<string, string>} addressMap - contract name as a key and address where it's deployed as value\n*/\nexport const getTimestampOffsetTemplate = async (addressMap = {}) => {\n  const envMap = await getEnvironment();\n  const fullMap = {\n  ...envMap,\n  ...addressMap,\n  };\n\n  // If there are any missing imports in fullMap it will be reported via console\n  reportMissingImports(CODE, fullMap, `getTimestampOffset =>`)\n\n  return replaceImportAddresses(CODE, fullMap);\n};\n\nexport const getTimestampOffset = async (props = {}) => {\n  const { addressMap = {}, args = [] } = props\n  const code = await getTimestampOffsetTemplate(addressMap);\n\n  reportMissing(\"arguments\", args.length, 0, `getTimestampOffset =>`);\n\n  return executeScript({code, processed: true, ...props})\n}","import { checkManagerTemplate, checkManager } from \"./checkManager\";\nimport { getAccountAddressTemplate, getAccountAddress } from \"./getAccountAddress\";\nimport { getBalanceTemplate, getBalance } from \"./getBalance\";\nimport { getBlockOffsetTemplate, getBlockOffset } from \"./getBlockOffset\";\nimport { getContractAddressTemplate, getContractAddress } from \"./getContractAddress\";\nimport { getManagerAddressTemplate, getManagerAddress } from \"./getManagerAddress\";\nimport { getTimestampOffsetTemplate, getTimestampOffset } from \"./getTimestampOffset\";\n\nexport default {\n  checkManagerTemplate,\n  checkManager,\n  getAccountAddressTemplate,\n  getAccountAddress,\n  getBalanceTemplate,\n  getBalance,\n  getBlockOffsetTemplate,\n  getBlockOffset,\n  getContractAddressTemplate,\n  getContractAddress,\n  getManagerAddressTemplate,\n  getManagerAddress,\n  getTimestampOffsetTemplate,\n  getTimestampOffset,\n};\n","import contracts from \"./contracts\";\nimport scripts from \"./scripts\";\nimport transactions from \"./transactions\";\n\nexport default {\n  contracts,\n  scripts,\n  transactions,\n};\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {config} from \"@onflow/config\"\nimport {withPrefix} from \"./address\"\nimport {hexContract} from \"./deploy-code\"\nimport registry from \"./generated\"\n\nexport const initManager = async () => {\n  const code = await registry.transactions.initManagerTemplate()\n  const contractCode = await registry.contracts.FlowManagerTemplate()\n  const hexedContract = hexContract(contractCode)\n  const args = [hexedContract]\n\n  await sendTransaction({\n    code,\n    args,\n    service: true,\n  })\n}\n\nexport const getServiceAddress = async () => {\n  return withPrefix(await config().get(\"SERVICE_ADDRESS\"))\n}\n\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress()\n\n  const addressMap = {\n    FlowManager: serviceAddress,\n  }\n\n  const code = await registry.scripts.checkManagerTemplate(addressMap)\n\n  let [result, e] = await executeScript({\n    code,\n    service: true,\n  })\n  if (e && result === null) {\n    await initManager()\n  }\n\n  return getServiceAddress()\n}\n\n// TODO: replace method above after Cadence will allow to get contracts list on PublicAccount\n/*\nexport const getManagerAddress = async () => {\n  const serviceAddress = await getServiceAddress();\n\n  const code = `\n    pub fun main(address: Address):Bool {\n      return getAccount(address).contracts.get(\"FlowManager\") != null\n    }\n  `;\n  const result = await executeScript({ code, args: [serviceAddress] });\n\n  if (!result) {\n    await initManager();\n  }\n\n  return serviceAddress;\n};\n */\n\nexport const getBlockOffset = async () => {\n  const FlowManager = await getManagerAddress()\n  const code = await registry.scripts.getBlockOffsetTemplate({FlowManager})\n  return executeScript({code})\n}\n\nexport const setBlockOffset = async offset => {\n  const FlowManager = await getManagerAddress()\n\n  const args = [offset]\n  const code = await registry.transactions.setBlockOffsetTemplate({FlowManager})\n  const payer = [FlowManager]\n\n  return sendTransaction({code, args, payer})\n}\n\nexport const getTimestampOffset = async () => {\n  const FlowManager = await getManagerAddress()\n  const code = await registry.scripts.getTimestampOffsetTemplate({FlowManager})\n  return executeScript({code})\n}\n\nexport const setTimestampOffset = async offset => {\n  const FlowManager = await getManagerAddress()\n\n  const args = [offset]\n  const code = await registry.transactions.setTimestampOffsetTemplate({\n    FlowManager,\n  })\n  const payer = [FlowManager]\n\n  return sendTransaction({code, args, payer})\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getManagerAddress} from \"./manager\"\nimport {executeScript} from \"./interaction\"\nimport {defaultsByName} from \"./file\"\n\nimport registry from \"./generated\"\n\n/**\n * Returns address of the account where contract specified by name is currently deployed\n * @param {string} name - name of the account to look for\n * @param {boolean} [useDefaults=false] - whether we shall look into default addressed first\n * @returns {Promise<string>}\n */\nexport const getContractAddress = async (name, useDefaults = false) => {\n  // TODO: Maybe try to automatically deploy contract? 🤔\n\n  if (useDefaults) {\n    const defaultContract = defaultsByName[name]\n    if (defaultContract !== undefined) {\n      return defaultContract\n    }\n  }\n\n  const managerAddress = await getManagerAddress()\n  const addressMap = {FlowManager: managerAddress}\n\n  const code = await registry.scripts.getContractAddressTemplate(addressMap)\n  const args = [name, managerAddress]\n  const [contractAddress] = await executeScript({\n    code,\n    args,\n    service: true,\n  })\n\n  return contractAddress\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getContractAddress} from \"./contract\"\nimport {defaultsByName} from \"./file\"\n\nconst REGEXP_IMPORT = /(\\s*import\\s*)([\\w\\d]+)(\\s+from\\s*)([\\w\\d\".\\\\/]+)/g\n\nconst getPairs = line => {\n  return line\n    .split(/\\s/)\n    .map(item => item.replace(/\\s/g, \"\"))\n    .filter(item => item.length > 0 && item !== \"import\" && item !== \"from\")\n}\n\nconst collect = (acc, item) => {\n  const [contract, address] = item\n  acc[contract] = address\n  return acc\n}\n\n/**\n * Returns address map for contracts defined in template code.\n * @param {string} code - Cadence code to parse.\n * @returns {*}\n */\nexport const extractImports = code => {\n  if (!code || code.length === 0) {\n    return {}\n  }\n  return code\n    .split(\"\\n\")\n    .filter(line => line.includes(\"import\"))\n    .map(getPairs)\n    .reduce(collect, {})\n}\n\nexport const replaceImports = (code, addressMap) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract) => {\n    const newAddress =\n      addressMap instanceof Function\n        ? addressMap(contract)\n        : addressMap[contract]\n    return `${imp}${contract} from ${newAddress}`\n  })\n}\n\n/**\n * Returns Cadence template code with replaced import addresses\n * @param {string} code - Cadence template code.\n * @param {{string:string}} [addressMap={}] - name/address map or function to use as lookup table\n * for addresses in import statements.\n * @param byName - lag to indicate whether we shall use names of the contracts.\n * @returns {*}\n */\nexport const replaceImportAddresses = (code, addressMap, byName = true) => {\n  return code.replace(REGEXP_IMPORT, (match, imp, contract, _, address) => {\n    const key = byName ? contract : address\n    const newAddress =\n      addressMap instanceof Function ? addressMap(key) : addressMap[key]\n    return `${imp}${contract} from ${newAddress}`\n  })\n}\n\n/**\n * Resolves import addresses defined in code template\n * @param {string} code - Cadence template code.\n * @returns {{string:string}} - name/address map\n */\nexport const resolveImports = async code => {\n  const addressMap = {}\n  const importList = extractImports(code)\n  for (const key in importList) {\n    if (defaultsByName[key]) {\n      addressMap[key] = defaultsByName[key]\n    } else {\n      const address = await getContractAddress(key)\n      addressMap[key] = address\n    }\n  }\n  return addressMap\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from \"fs\"\nimport path from \"path\"\nimport {config} from \"@onflow/config\"\n\nimport {replaceImportAddresses} from \"./imports\"\nimport {isObject} from \"./utils\"\n\nexport const readFile = path => {\n  return fs.readFileSync(path, \"utf8\")\n}\n\n/**\n * Address map with access by name for contracts deployed to emulator by default.\n * @type {{FlowFees: string, FlowToken: string, FungibleToken: string}}\n */\nexport const defaultsByName = {\n  FlowToken: \"0x0ae53cb6e3f42a79\",\n  FungibleToken: \"0xee82856bf20e2aa6\",\n  FlowFees: \"0xe5a8b7f23e8b548f\",\n  FlowStorageFees: \"0xf8d6e0586b0a20c7\",\n}\n\n/**\n * Address map with access by address for contracts deployed to emulator by default.\n * @type {{\"0xe5a8b7f23e8b548f\": string, \"0xf8d6e0586b0a20c7\": string, \"0xee82856bf20e2aa6\": string, \"0x0ae53cb6e3f42a79\": string}}\n */\nexport const defaultsByAddress = {\n  \"0xe5a8b7f23e8b548f\": \"0xe5a8b7f23e8b548f\", // FlowFees\n  \"0xf8d6e0586b0a20c7\": \"0xf8d6e0586b0a20c7\", // FlowStorageFees\n  \"0x0ae53cb6e3f42a79\": \"0x0ae53cb6e3f42a79\", // FlowToken\n  \"0xee82856bf20e2aa6\": \"0xee82856bf20e2aa6\", // FungibleToken\n}\n\nconst SCRIPT = \"scripts\"\nconst TRANSACTION = \"transactions\"\nconst CONTRACT = \"contracts\"\n\nexport const templateType = {\n  SCRIPT,\n  TRANSACTION,\n  CONTRACT,\n}\n\nexport const getPath = async (name, type = TRANSACTION) => {\n  const configBase = await config().get(\"BASE_PATH\")\n\n  // We can simply overwrite \"configBase\" variable, but I believe it's better to leave it unchanged\n  let basePath = configBase\n\n  // It's possible to pass a set of paths via object, so we need to check if that's the case\n  if (isObject(configBase)) {\n    const typePath = configBase[type]\n\n    // if there is a specific path for this type, then we shall resolve it\n    if (typePath) {\n      return path.resolve(typePath, `./${name}.cdc`)\n    }\n\n    // otherwise use \"base\" value\n    basePath = configBase.base\n  }\n\n  return path.resolve(basePath, `./${type}/${name}.cdc`)\n}\n\n/**\n * Returns Cadence template for specified file. Replaces imports using provided address map\n * @param file - name of the file to look for.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @param {boolean} [byAddress=false] - flag to indicate if address map is address to address type.\n * @returns {string}\n */\nexport const getTemplate = (file, addressMap = {}, byAddress = false) => {\n  const rawCode = readFile(file)\n\n  const defaults = byAddress ? defaultsByAddress : defaultsByName\n\n  return addressMap\n    ? replaceImportAddresses(rawCode, {\n        ...defaults,\n        ...addressMap,\n      })\n    : rawCode\n}\n\n/**\n * Returns contract template using name of the file in \"contracts\" folder containing the code.\n * @param name - name of the contract template in \"contract\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getContractCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.CONTRACT)\n  return getTemplate(path, addressMap)\n}\n\n/**\n * Returns transaction template using name of the file in \"transactions\" folder containing the code.\n * @param name - name of the transaction template in \"transactions\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getTransactionCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.TRANSACTION)\n  return getTemplate(path, addressMap)\n}\n\n/**\n * Returns script template using name of the file in \"scripts\" folder containing the code.\n * @param name - name of the script template in \"scripts\" folder.\n * @param {{string:string}} [addressMap={}] - name/address map to use as lookup table for addresses in import statements.\n * @returns {Promise<string>}\n */\nexport const getScriptCode = async ({name, addressMap}) => {\n  const path = await getPath(name, templateType.SCRIPT)\n  return getTemplate(path, addressMap)\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport registry from \"./generated\"\nimport {defaultsByName} from \"./file\"\n\nconst FlowTokenMap = {ExampleToken: defaultsByName.FlowToken}\n\nconst lowerFirst = name => {\n  return name[0].toLowerCase() + name.slice(1)\n}\n\nexport const makeMintTransaction = async name => {\n  const code = await registry.transactions.mintTokensTemplate(FlowTokenMap)\n  const pattern = /(ExampleToken)/gi\n\n  return code.replace(pattern, match => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name)\n  })\n}\n\nexport const makeGetBalance = async name => {\n  const code = await registry.scripts.getBalanceTemplate(FlowTokenMap)\n  const pattern = /(ExampleToken)/gi\n\n  return code.replace(pattern, match => {\n    return match === \"ExampleToken\" ? name : lowerFirst(name)\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {defaultsByName} from \"./file\"\nimport {replaceImportAddresses} from \"./imports\"\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {makeGetBalance, makeMintTransaction} from \"./templates\"\n\n/**\n * Returns current FlowToken balance of account specified by address\n * @param {string} address - address of account to check\n * @returns {Promise<*>}\n */\nexport const getFlowBalance = async address => {\n  const raw = await makeGetBalance(\"FlowToken\")\n  const code = replaceImportAddresses(raw, defaultsByName)\n  const args = [address]\n\n  return executeScript({code, args})\n}\n\n/**\n * Sends transaction to mint specified amount of FlowToken and send it to recipient.\n * Returns result of the transaction.\n * @param {string} recipient - address of recipient account\n * @param {string} amount - amount to mint and send\n * @returns {Promise<*>}\n */\nexport const mintFlow = async (recipient, amount) => {\n  const raw = await makeMintTransaction(\"FlowToken\")\n  const code = replaceImportAddresses(raw, defaultsByName)\n  const args = [recipient, amount]\n  return sendTransaction({code, args})\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {pubFlowKey} from \"./crypto\"\nimport {executeScript, sendTransaction} from \"./interaction\"\nimport {getManagerAddress} from \"./manager\"\n\nimport registry from \"./generated\"\n\n/**\n * Returns address of account specified by name. If account with that name doesn't exist it will be created\n * and assigned provided name as alias\n * @param {string} accountName - name of the account\n * @returns {Promise<string|*>}\n */\nexport const getAccountAddress = async accountName => {\n  const name =\n    accountName ||\n    `deployment-account-${(Math.random() * Math.pow(10, 8)).toFixed(0)}`\n\n  const managerAddress = await getManagerAddress()\n\n  const addressMap = {\n    FlowManager: managerAddress,\n  }\n\n  let accountAddress\n\n  const code = await registry.scripts.getAccountAddressTemplate(addressMap)\n\n  const args = [name, managerAddress]\n\n  const [result] = await executeScript({\n    code,\n    args,\n    service: true,\n  })\n  accountAddress = result\n\n  if (accountAddress === null) {\n    const code = await registry.transactions.createAccountTemplate(addressMap)\n    const publicKey = await pubFlowKey()\n    const args = [name, publicKey, managerAddress]\n\n    const [result] = await sendTransaction({\n      code,\n      args,\n    })\n    const {events} = result\n    const event = events.find(event => event.type.includes(\"AccountAdded\"))\n    accountAddress = event.data.address\n  }\n  return accountAddress\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {expect} = global\n\n/**\n * Return Promise from passed interaction\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*>\n * */\nexport const promise = async ix => {\n  if (typeof ix === \"function\") {\n    return await ix()\n  }\n  return await ix\n}\n\n/**\n * Ensure transaction did not throw and sealed.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - transaction result\n * */\nexport const shallPass = async ix => {\n  const wrappedInteraction = promise(ix)\n\n  const response = await wrappedInteraction\n  const [result, error] = response\n\n  if (error) {\n    throw error\n  }\n\n  let resolvedStatus\n  let resolvedErrorMessage\n  if (Array.isArray(result)) {\n    const {status, errorMessage} = result\n    resolvedStatus = status\n    resolvedErrorMessage = errorMessage\n  } else {\n    const {status, errorMessage} = result\n    resolvedStatus = status\n    resolvedErrorMessage = errorMessage\n  }\n\n  await expect(resolvedStatus).toBe(4)\n  await expect(resolvedErrorMessage).toBe(\"\")\n\n  return response\n}\n\n/**\n * Ensure interaction did not throw and return result of it\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> - result of interaction\n * */\nexport const shallResolve = async ix => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n  const [, error] = response\n  expect(error).toBe(null)\n\n  return response\n}\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @param {string | RegExp} [message] - Expected error message provided as either a string equality or regular expression\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallRevert = async (ix, message) => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n  const [result, error] = response\n\n  await expect(result).toBe(null)\n\n  if (message) {\n    const errorMessage = error\n      .toString()\n      .match(/^error: (panic)|(assertion failed): ([^\\r\\n]*)$/m)\n      ?.at(3)\n    if (message instanceof RegExp) {\n      await expect(errorMessage).toMatch(message)\n    } else {\n      await expect(errorMessage).toBe(message)\n    }\n  } else {\n    await expect(error).not.toBe(null)\n  }\n\n  return response\n}\n\n/**\n * Ensure interaction throws an error.\n * @param {function | Promise} ix - Promise or function to wrap\n * @returns Promise<*> -  result of interaction\n * */\nexport const shallThrow = async ix => {\n  const wrappedInteraction = promise(ix)\n  const response = await wrappedInteraction\n\n  const [result, error] = response\n  await expect(result).toBe(null)\n  await expect(error).not.toBe(null)\n\n  return response\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getServiceAddress} from \"./manager\"\n\nexport const importManager = async () => {\n  const serviceAddress = await getServiceAddress()\n  return `import FlowManager from ${serviceAddress}`\n}\n\nexport const importExists = (contractName, code) => {\n  return new RegExp(`import\\\\s+${contractName}`).test(code)\n}\n\nexport const builtInMethods = async code => {\n  let injectedImports = code\n  if (!importExists(\"FlowManager\", code)) {\n    const imports = await importManager()\n    injectedImports = `\n      ${imports}\n      ${code}  \n  `\n  }\n  return injectedImports\n    .replace(/getCurrentBlock\\(\\).height/g, `FlowManager.getBlockHeight()`)\n    .replace(\n      /getCurrentBlock\\(\\).timestamp/g,\n      `FlowManager.getBlockTimestamp()`\n    )\n}\n\nconst addressToIndex = address => {\n  return parseInt(address) - 1\n}\n\nconst addressToAlias = accounts => address => accounts[addressToIndex(address)]\n\nexport const playgroundImport = accounts => async code => {\n  let injectedImports = code\n  if (!importExists(\"FlowManager\", code)) {\n    const imports = await importManager()\n    injectedImports = `\n      ${imports}\n      ${code}  \n  `\n  }\n  return injectedImports.replace(/(?:getAccount\\()(.+)(?:\\))/g, (match, g1) => {\n    const alias = addressToAlias(accounts)(g1)\n    if (!alias) {\n      return `getAccount(FlowManager.resolveDefaultAccounts(${g1}))`\n    }\n    return `getAccount(FlowManager.getAccountAddress(\"${alias}\"))`\n  })\n}\n","/*\n * Flow JS Testing\n *\n * Copyright 2020-2021 Dapper Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {send, build, getBlock, decode} from \"@onflow/fcl\"\nimport {config} from \"@onflow/config\"\nimport {getAvailablePorts} from \"./utils\"\n\nconst {spawn} = require(\"child_process\")\n\nconst DEFAULT_HTTP_PORT = 8080\nconst DEFAULT_GRPC_PORT = 3569\n\nconst print = {\n  log: console.log,\n  service: console.log,\n  info: console.log,\n  error: console.error,\n  warn: console.warn,\n}\n\n/** Class representing emulator */\nexport class Emulator {\n  /**\n   * Create an emulator.\n   */\n  constructor() {\n    this.initialized = false\n    this.logging = false\n    this.filters = []\n    this.logProcessor = item => item\n  }\n\n  /**\n   * Set logging flag.\n   * @param {boolean} logging - whether logs shall be printed\n   */\n  setLogging(logging) {\n    this.logging = logging\n  }\n\n  /**\n   * Log message with a specific type.\n   * @param {*} message - message to put into log output\n   * @param {\"log\"|\"error\"} type - type of the message to output\n   */\n  log(message, type = \"log\") {\n    if (this.logging !== false) {\n      print[type](message)\n    }\n  }\n\n  checkLevel(message, level) {\n    if (level === \"debug\") {\n      // We might need to find a better way for this, but this will do for now...\n      return message.includes(\"LOG\") ? \"log\" : level\n    }\n    return level\n  }\n\n  extractKeyValue(str) {\n    // TODO: add regexp check that it conforms to necessary pattern\n    const [key, value] = str.split(\"=\")\n    if (value.includes(\"LOG\")) {\n      return {key, value: value.replace(`\"\\x1b[1;34m`, `\"\\x1b[1[34m`)}\n    }\n    return {key, value}\n  }\n\n  fixJSON(msg) {\n    const splitted = msg.split(\"\\n\").filter(item => item !== \"\")\n    const reconstructed =\n      splitted.length > 1 ? `[${splitted.join(\",\")}]` : splitted[0]\n    return reconstructed\n  }\n\n  parseDataBuffer(data) {\n    const message = data.toString()\n    try {\n      if (message.includes(\"msg\")) {\n        return JSON.parse(this.fixJSON(message))\n      }\n    } catch (e) {\n      console.error(e)\n      return {msg: e, level: \"JSON Error\"}\n    }\n    return {msg: message, level: \"parser\"}\n  }\n\n  /**\n   * Start emulator.\n   * @param {number} port - port to use for accessApi\n   * @param {boolean} logging - whether logs shall be printed\n   * @returns Promise<*>\n   */\n  async start(options = {}) {\n    // populate emulator ports with available ports\n    ;[this.grpcPort, this.restPort, this.adminPort] = await getAvailablePorts(3)\n\n    // override ports if specified in options\n    this.grpcPort = options.grpcPort || this.grpcPort\n    this.restPort = options.restPort || this.restPort\n    this.adminPort = options.adminPort || this.adminPort\n\n    // Support deprecated start call using static port\n    if (arguments.length > 1 || typeof arguments[0] === \"number\") {\n      console.warn(`Calling emulator.start with the port argument is now deprecated in favour of dynamically selected ports and will be removed in future versions of flow-js-testing.\nPlease refrain from supplying this argument, as using it may cause unintended consequences.\nMore info: https://github.com/onflow/flow-js-testing/blob/master/TRANSITIONS.md#001-deprecate-emulatorstart-port-argument`)\n      ;[this.adminPort, options = {}] = arguments\n\n      const offset = this.adminPort - DEFAULT_HTTP_PORT\n      this.grpcPort = DEFAULT_GRPC_PORT + offset\n    }\n\n    const {flags = \"\", logging = false} = options\n\n    // config access node\n    config().put(\"accessNode.api\", `http://localhost:${this.restPort}`)\n\n    this.logging = logging\n    this.process = spawn(\"flow\", [\n      \"emulator\",\n      \"--verbose\",\n      `--log-format=JSON`,\n      `--rest-port=${this.restPort}`,\n      `--admin-port=${this.adminPort}`,\n      `--port=${this.grpcPort}`,\n      flags,\n    ])\n    this.logProcessor = item => item\n\n    // Suppress logger warning while waiting for emulator\n    await config().put(\"logger.level\", 0)\n\n    return new Promise((resolve, reject) => {\n      let internalId\n      const checkLiveness = async function () {\n        try {\n          await send(build([getBlock(false)])).then(decode)\n          clearInterval(internalId)\n\n          // Enable logger after emulator has come online\n          await config().put(\"logger.level\", 2)\n          this.initialized = true\n          resolve(true)\n        } catch (err) {} // eslint-disable-line no-unused-vars, no-empty\n      }\n      internalId = setInterval(checkLiveness, 100)\n\n      this.process.stdout.on(\"data\", buffer => {\n        const data = this.parseDataBuffer(buffer)\n        if (Array.isArray(data)) {\n          let filtered = []\n          if (this.filters.length > 0) {\n            filtered = data.filter(item => {\n              const level = this.checkLevel(item.msg, item.level)\n              return this.filters.includes(level)\n            })\n          }\n          for (let i = 0; i < filtered.length; i++) {\n            const item = data[i]\n            const {msg} = item\n            const level = this.checkLevel(msg, item.level)\n            this.log(`${level.toUpperCase()}: ${msg}`)\n          }\n        } else {\n          const {msg} = data\n          const level = this.checkLevel(msg, data.level)\n          if (this.filters.length > 0) {\n            if (this.filters.includes(level)) {\n              this.log(`${level.toUpperCase()}: ${msg}`)\n              // TODO: Fix this\n              // This is really hacky solution, which depends on specific phrasing\n              if (msg.includes(\"Starting\") && msg.includes(this.adminPort)) {\n                this.log(\"EMULATOR IS UP! Listening for events!\")\n              }\n            }\n          } else {\n            this.log(`${level.toUpperCase()}: ${msg}`)\n            if (data.msg.includes(\"Starting HTTP server\")) {\n              this.log(\"EMULATOR IS UP! Listening for events!\")\n            }\n          }\n        }\n      })\n\n      this.process.stderr.on(\"data\", buffer => {\n        const {message} = this.parseDataBuffer(buffer)\n        this.log(`EMULATOR ERROR: ${message}`, \"error\")\n        this.initialized = false\n        clearInterval(internalId)\n        reject()\n      })\n\n      this.process.on(\"close\", code => {\n        if (this.filters.includes(\"service\")) {\n          this.log(`EMULATOR: process exited with code ${code}`)\n        }\n        this.initialized = false\n        clearInterval(internalId)\n        resolve(false)\n      })\n    })\n  }\n\n  /**\n   * Clear all log filters.\n   * @returns void\n   **/\n  clearFilters() {\n    this.filters = []\n  }\n\n  /**\n   * Remove specific type of log filter.\n   * @param {(debug|info|warning)} type - type of message\n   * @returns void\n   **/\n  removeFilter(type) {\n    this.filters = this.filters.filter(item => item !== type)\n  }\n\n  /**\n   * Add log filter.\n   * @param {(debug|info|warning)} type type - type of message\n   * @returns void\n   **/\n  addFilter(type) {\n    if (!this.filters.includes(type)) {\n      this.filters.push(type)\n    }\n  }\n\n  /**\n   * Stop emulator.\n   * @returns Promise<*>\n   */\n  async stop() {\n    // eslint-disable-next-line no-undef\n    return new Promise(resolve => {\n      this.process.kill()\n      setTimeout(() => {\n        this.initialized = false\n        resolve(false)\n      }, 50)\n    })\n  }\n}\n\n/** Singleton instance */\nexport default new Emulator()\n"],"names":["get","scope","path","fallback","split","length","head","rest","_error","set","key","env","conf","value","flowConfig","config","put","getConfigValue","init","basePath","props","pkey","process","sansPrefix","address","replace","withPrefix","ec","EC","signWithKey","privateKey","msgHex","sig","keyFromPrivate","Buffer","from","sign","sha","SHA3","update","digest","hashMsgHex","r","toArrayLike","s","concat","toString","authorization","addr","keyId","account","serviceAddress","tempId","fcl","signingFunction","data","signature","message","isObject","arg","getAvailablePorts","count","Promise","resolve","reject","server","createServer","listen","port","close","err","_settle","pact","state","_Pact","o","bind","v","then","observer","prototype","onFulfilled","onRejected","result","this","callback","e","_this","body","recover","extractParameters","ixType","params","getServiceAddress","code","ixCode","signers","ixSigners","args","ixArgs","limit","ixLimit","addressMap","defaultsByName","deployedContracts","FlowManager","replaceImportAddresses","target","check","keys","push","array","i","_cycle","thenable","transformer","ixTransformers","ixService","resolveImports","ixName","name","transformers","service","Error","getScriptCode","getTransactionCode","sendTransaction","extractor","send","ix","response","tx","onceExecuted","serviceAuth","transaction","payer","proposer","auths","map","authorizations","resolveArguments","resolvedArgs","executeScript","decode","script","CODE","createAccountTemplate","getEnvironment","envMap","fullMap","reportMissingImports","deployContractTemplate","initManagerTemplate","mintTokensTemplate","registerContractTemplate","scratchTemplate","setBlockOffsetTemplate","setTimestampOffsetTemplate","updateContractTemplate","createAccount","reportMissing","processed","mintTokens","registerContract","scratch","updateContract","txRegistry","hexContract","contract","ixTo","ixAddressMap","ixUpdate","to","deployContractByName","resolvedAddress","getContractCode","contractCode","test","deployContract","extractContractParameters","containerAddress","managerAddress","hexedCode","deployArgs","schema","generateSchema","item","splitArgs","argLetter","argList","contractName","transactions","getManagerAddress","registry","hexedContract","initManager","getBlockOffset","setBlockOffset","offset","getTimestampOffset","setTimestampOffset","getContractAddress","useDefaults","defaultContract","undefined","contractAddress","REGEXP_IMPORT","getPairs","line","filter","collect","acc","extractImports","includes","reduce","byName","match","imp","_","Function","_forTo","FlowToken","FungibleToken","FlowFees","FlowStorageFees","defaultsByAddress","getPath","type","configBase","typePath","base","getTemplate","file","byAddress","rawCode","fs","readFileSync","readFile","FlowTokenMap","ExampleToken","lowerFirst","toLowerCase","slice","getFlowBalance","makeGetBalance","raw","mintFlow","recipient","amount","makeMintTransaction","getAccountAddress","accountName","Math","random","pow","toFixed","accountAddress","_Buffer","publicKey","getPublic","rlp","encode","pubFlowKey","events","event","find","expect","global","promise","shallPass","wrappedInteraction","error","resolvedStatus","resolvedErrorMessage","Array","isArray","status","errorMessage","toBe","shallResolve","shallRevert","not","_error$toString$match","at","RegExp","toMatch","shallThrow","builtInMethods","injectedImports","importExists","importManager","imports","spawn","require","print","log","console","info","warn","constructor","initialized","logging","filters","logProcessor","setLogging","checkLevel","level","extractKeyValue","str","fixJSON","msg","splitted","join","parseDataBuffer","JSON","parse","start","options","arguments","grpcPort","restPort","adminPort","_arguments","flags","internalId","setInterval","build","getBlock","clearInterval","_this2","stdout","on","buffer","filtered","toUpperCase","stderr","clearFilters","removeFilter","addFilter","stop","_this3","kill","setTimeout"],"mappings":"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"}
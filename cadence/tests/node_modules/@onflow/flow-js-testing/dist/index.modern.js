import{flowConfig as e}from"@onflow/fcl-config";import{config as t}from"@onflow/config";import n from"fs";import a from"path";import*as r from"@onflow/fcl";import{send as s,build as o,getBlock as c,decode as i}from"@onflow/fcl";import{resolveArguments as l,getEnvironment as g,reportMissingImports as u,replaceImportAddresses as d,reportMissing as p,sendTransaction as f,extractContractParameters as m,generateSchema as w,splitArgs as h,deployContract as M,executeScript as b}from"@onflow/flow-cadut";import{ec as A}from"elliptic";import{SHA3 as y}from"sha3";import*as k from"rlp";import{createServer as T}from"net";const x=(e,t,n)=>{if("string"==typeof t)return x(e,t.split("/"),n);if(!t.length)return e;try{const[a,...r]=t;return x(e[a],r,n)}catch(e){return n}},F=(n,a,r,s)=>{let o=x(e(),r,s);o||(o=s),t().put(n,o)},S=async e=>t().get(e),v=async(e,t={})=>{const{pkey:n="48a1f554aeebf6bf9fe0d7b5b79d080700b073ee77909973ea0b2f6fbc902"}=t;F("PRIVATE_KEY",process,"accounts/emulator-account/key",n),F("SERVICE_ADDRESS",process,"accounts/emulator-account/address","f8d6e0586b0a20c7"),F("BASE_PATH",process,"testing/paths",e)};function P(){return P=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},P.apply(this,arguments)}const B=e=>null==e?null:e.replace(/^0x/,""),E=e=>null==e?null:"0x"+B(e),O=new A("p256"),C=(e,t)=>{const n=O.keyFromPrivate(Buffer.from(e,"hex")).sign((e=>{const t=new y(256);return t.update(Buffer.from(e,"hex")),t.digest()})(t)),a=n.r.toArrayLike(Buffer,"be",32),r=n.s.toArrayLike(Buffer,"be",32);return Buffer.concat([a,r]).toString("hex")},I=(e,n=0)=>async(a={})=>{const s=await t().get("SERVICE_ADDRESS"),o=await t().get("PRIVATE_KEY");return P({},a,{tempId:`${e=B(e||s)}-${n}`,addr:r.sansPrefix(e),keyId:n,signingFunction:async t=>({keyId:n,addr:E(e),signature:C(o,t.message)})})},R=e=>"object"==typeof e&&null!==e;function U(e=1){return 0===e?Promise.resolve([]):new Promise((t,n)=>{const a=T();a.listen(0,()=>{const r=a.address().port;a.close(async a=>{a&&n(a),t([...await U(e-1),r])})})})}const $=e=>async t=>{let n,a,r,s,o,c,i,l;if(R(t[0])){const[e]=t,{name:l,code:g,args:u,signers:d,transformers:p,limit:f,service:m=!1}=e;if(o=m,!l&&!g)throw Error("Both `name` and `code` are missing. Provide either of them");a=l,n=g,r=d,s=u,c=p||[],i=f}else"script"===e?[a,s,i,c]=t:[a,r,s,i,c]=t;if(i=i||999,a){const t="script"===e?$e:Ue;n=await t({name:a})}l=o?Ee:await Be(n);const g=await he(),u=P({},Ee,l,{FlowManager:g});n=Pe(n,u);for(const e in c){const t=c[e];n=await t(n)}return{code:n,signers:r,args:s,limit:i}},_=async(...e)=>{try{const t=$("tx"),{code:n,args:a,signers:s,limit:o}=await t(e),c=I(),i=[r.transaction(n),r.payer(c),r.proposer(c),r.limit(o)];if(s){const e=s.map(e=>I(e));i.push(r.authorizations(e))}else i.push(r.authorizations([c]));if(a){const e=await l(a,n);i.push(r.args(e))}const g=await r.send(i);return[await r.tx(g).onceExecuted(),null]}catch(e){return[null,e]}},L=async(...e)=>{try{const t=$("script"),{code:n,args:a,limit:s}=await t(e),o=[r.script(n),r.limit(s)];if(a){const e=await l(a,n);o.push(r.args(e))}const c=await r.send(o);return[await r.decode(c),null]}catch(e){return[null,e]}},D="\nimport FlowManager from 0x01\n\ntransaction (_ name: String, pubKey: String, manager: Address) {\n    prepare( admin: AuthAccount) {\n        let newAccount = AuthAccount(payer:admin)\n        newAccount.addPublicKey(pubKey.decodeHex())\n\n        let linkPath = FlowManager.accountManagerPath\n        let accountManager = getAccount(manager)\n                            .getCapability(linkPath)!\n                            .borrow<&FlowManager.Mapper>()!\n        \n        // Create a record in account database\n        let address = newAccount.address\n        accountManager.setAddress(name, address: address)\n    }\n}\n\n",N=async(e={})=>{const t=P({},await g(),e);return u(D,t,"createAccount =>"),d(D,t)},H="\nimport FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        acct.contracts.add(\n           name: name,\n           code: decoded,\n           ##ARGS-LIST##\n        )\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",G=async(e={})=>{const t=P({},await g(),e);return u(H,t,"deployContract =>"),d(H,t)},K='\ntransaction ( code: String ) {\n    prepare( admin: AuthAccount) {\n        admin.contracts.add(\n           name: "FlowManager",\n           code: code.decodeHex(),\n        )\n   }\n}\n\n',V=async(e={})=>{const t=P({},await g(),e);return u(K,t,"initManager =>"),d(K,t)},z='\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic("Signer is not the token admin")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic("Unable to borrow receiver reference")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n',j=async(e={})=>{const t=P({},await g(),e);return u(z,t,"mintTokens =>"),d(z,t)},Y="\nimport FlowManager from 0x01\n\ntransaction(name: String, address: Address) {\n    prepare(signer: AuthAccount){\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = signer\n                                .getCapability(linkPath)!\n                                .borrow<&FlowManager.Mapper>()!\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",J=async(e={})=>{const t=P({},await g(),e);return u(Y,t,"registerContract =>"),d(Y,t)},W="\ntransaction{\n    prepare(acct: AuthAccount){\n        log(acct.address)\n    }\n}\n",q=async(e={})=>{const t=P({},await g(),e);return u(W,t,"scratch =>"),d(W,t)},Q="\nimport FlowManager from 0x01\n\ntransaction(offset: UInt64){\n    prepare(signer:AuthAccount){\n        FlowManager.setBlockOffset(offset)\n    }\n}\n\n",X=async(e={})=>{const t=P({},await g(),e);return u(Q,t,"setBlockOffset =>"),d(Q,t)},Z="\nimport FlowManager from 0x01\n\ntransaction(offset: UFix64){\n    prepare(signer:AuthAccount){\n        FlowManager.setTimestampOffset(offset)\n    }\n}\n\n",ee=async(e={})=>{const t=P({},await g(),e);return u(Z,t,"setTimestampOffset =>"),d(Z,t)},te="\nimport FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",ne=async(e={})=>{const t=P({},await g(),e);return u(te,t,"updateContract =>"),d(te,t)};var ae={createAccountTemplate:N,createAccount:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await N(t);return p("arguments",n.length,3,"createAccount =>"),p("signers",a.length,1,"createAccount =>"),f(P({code:r,processed:!0},e))},deployContractTemplate:G,deployContract:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await G(t);return p("arguments",n.length,3,"deployContract =>"),p("signers",a.length,1,"deployContract =>"),f(P({code:r,processed:!0},e))},initManagerTemplate:V,initManager:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await V(t);return p("arguments",n.length,1,"initManager =>"),p("signers",a.length,1,"initManager =>"),f(P({code:r,processed:!0},e))},mintTokensTemplate:j,mintTokens:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await j(t);return p("arguments",n.length,2,"mintTokens =>"),p("signers",a.length,1,"mintTokens =>"),f(P({code:r,processed:!0},e))},registerContractTemplate:J,registerContract:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await J(t);return p("arguments",n.length,2,"registerContract =>"),p("signers",a.length,1,"registerContract =>"),f(P({code:r,processed:!0},e))},scratchTemplate:q,scratch:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await q(t);return p("arguments",n.length,0,"scratch =>"),p("signers",a.length,1,"scratch =>"),f(P({code:r,processed:!0},e))},setBlockOffsetTemplate:X,setBlockOffset:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await X(t);return p("arguments",n.length,1,"setBlockOffset =>"),p("signers",a.length,1,"setBlockOffset =>"),f(P({code:r,processed:!0},e))},setTimestampOffsetTemplate:ee,setTimestampOffset:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await ee(t);return p("arguments",n.length,1,"setTimestampOffset =>"),p("signers",a.length,1,"setTimestampOffset =>"),f(P({code:r,processed:!0},e))},updateContractTemplate:ne,updateContract:async(e={})=>{const{addressMap:t,args:n=[],signers:a=[]}=e,r=await ne(t);return p("arguments",n.length,3,"updateContract =>"),p("signers",a.length,1,"updateContract =>"),f(P({code:r,processed:!0},e))}};const{updateContractTemplate:re,deployContractTemplate:se}=ae,oe=e=>Buffer.from(e,"utf8").toString("hex"),ce=async(...e)=>{const t=await(async e=>{let t,n,a,r,s;if(R(e[0])){const[o]=e,{name:c,to:i,addressMap:l,args:g,update:u}=o;if(!c)throw Error("'name' field is missing");t=c,n=i,r=g,a=l,s=u}else[t,n,a,r,s]=e;const o=await he();return{name:t,to:n,args:r,update:s,addressMap:P({},Ee,{FlowManager:o},a)}})(e),{to:n,name:a,addressMap:r,args:s,update:o=!1}=t,c=n||await he(),i=await Re({name:a,addressMap:r}),l=/[\\/]/.test(a)?null:a;return ie({to:c,code:i,name:l,args:s,update:o})},ie=async e=>{const{to:t,code:n,name:a,args:r,update:s}=e,o=await m(n),c=a||o.contractName,i=t||await he(),l=await he(),g=await Be(n),u=await he(),d=P({},Ee,g,{FlowManager:u}),p=oe(Pe(n,d));let f=s?await re(d):await se(d),M=[c,p,l];if(r){M=M.concat(r);const e=w(o.args).map(e=>h(e)[0]),t="abcdefghijklmnopqrstuvwxyz";let n=[];for(let a=0;a<e.length;a++)n.push(`${t[a]}: ${e[a]}`);f=f.replace("##ARGS-WITH-TYPES##",`, ${o.args}`),f=f.replace("##ARGS-LIST##",n)}else f=f.replace("##ARGS-WITH-TYPES##",""),f=f.replace("##ARGS-LIST##","");return _({code:f,args:M,signers:[i]})},le='\npub contract FlowManager {\n\n    /// Account Manager\n    pub event AccountAdded(address: Address)\n\n    pub struct Mapper {\n        pub let accounts: {String: Address}\n\n        pub fun getAddress(_ name: String): Address? {\n            return self.accounts[name]\n        }\n\n        pub fun setAddress(_ name: String, address: Address){\n            self.accounts[name] = address\n            emit FlowManager.AccountAdded(address: address)\n        }\n\n        init(){\n            self.accounts = {}\n        }\n    }\n\n    pub fun getAccountAddress(_ name: String): Address?{\n        let accountManager = self.account\n            .getCapability(self.accountManagerPath)\n            .borrow<&FlowManager.Mapper>()!\n\n        return accountManager.getAddress(name)\n    }\n\n    pub let defaultAccounts: {Address : String}\n\n    pub fun resolveDefaultAccounts(_ address: Address): Address{\n        let alias = self.defaultAccounts[address]!\n        return self.getAccountAddress(alias)!\n    }\n\n    pub let accountManagerStorage: StoragePath\n    pub let contractManagerStorage: StoragePath\n    pub let accountManagerPath: PublicPath\n    pub let contractManagerPath: PublicPath\n\n    /// Environment Manager\n    pub event BlockOffsetChanged(offset: UInt64)\n    pub event TimestampOffsetChanged(offset: UFix64)\n\n    pub struct MockBlock {\n        pub let id: [UInt8; 32]\n        pub let height: UInt64\n        pub let view: UInt64\n        pub let timestamp: UFix64\n\n        init(_ id: [UInt8; 32], _ height: UInt64, _ view: UInt64, _ timestamp: UFix64){\n            self.id = id\n            self.height = height\n            self.view = view\n            self.timestamp = timestamp\n        }\n    }\n\n    pub fun setBlockOffset(_ offset: UInt64){\n        self.blockOffset = offset\n        emit FlowManager.BlockOffsetChanged(offset: offset)\n    }\n\n    pub fun setTimestampOffset(_ offset: UFix64){\n        self.timestampOffset = offset\n        emit FlowManager.TimestampOffsetChanged(offset: offset)\n    }\n\n    pub fun getBlockHeight(): UInt64 {\n        var block = getCurrentBlock()\n        return block.height + self.blockOffset\n    }\n\n    pub fun getBlockTimestamp(): UFix64 {\n        var block = getCurrentBlock()\n        return block.timestamp + self.timestampOffset\n    }\n\n    pub fun getBlock(): MockBlock {\n        var block =  getCurrentBlock()\n        let mockBlock = MockBlock(block.id, block.height, block.view, block.timestamp);\n        return mockBlock\n    }\n\n    pub var blockOffset: UInt64;\n    pub var timestampOffset: UFix64;\n\n\n    // Initialize contract\n    init(){\n        // Environment defaults\n        self.blockOffset = 0;\n        self.timestampOffset = 0.0;\n\n        // Account Manager initialization\n        let accountManager = Mapper()\n        let contractManager = Mapper()\n\n        self.defaultAccounts = {\n          0x01: "Alice",\n          0x02: "Bob",\n          0x03: "Charlie",\n          0x04: "Dave",\n          0x05: "Eve"\n        }\n\n        self.accountManagerStorage = /storage/testSuiteAccountManager\n        self.contractManagerStorage = /storage/testSuiteContractManager\n\n        self.accountManagerPath = /public/testSuiteAccountManager\n        self.contractManagerPath = /public/testSuiteContractManager\n        \n        // Destroy previously stored values\n        self.account.load<Mapper>(from: self.accountManagerStorage)\n        self.account.load<Mapper>(from: self.contractManagerStorage)\n\n        self.account.save(accountManager, to: self.accountManagerStorage)\n        self.account.save(contractManager, to: self.contractManagerStorage)\n\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\n    }\n}\n \n',ge="\nimport FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty, cause script will throw error if FlowManager is not\n    // added to service address\n}\n\n",ue="\nimport FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.accountManagerPath\n    let accountManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return accountManager.getAddress(name)\n\n}\n",de='\n// This script reads the balance field of an account\'s FlowToken Balance\n\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\npub fun main(account: Address): UFix64 {\n    let acct = getAccount(account)\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\n        ?? panic("Could not borrow Balance reference to the Vault")\n\n    return vaultRef.balance\n}\n',pe="\nimport FlowManager from 0x01\n\npub fun main():UInt64 {\n    return FlowManager.blockOffset\n}\n\n",fe="\nimport FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.contractManagerPath\n    let contractManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return contractManager.getAddress(name)\n\n}\n",me="\nimport FlowManager from 0x01\n\npub fun main():UFix64 {\n    return FlowManager.timestampOffset\n}\n\n";var we=ae;const he=async()=>E(await t().get("SERVICE_ADDRESS")),Me=async()=>{const e={FlowManager:await he()},t=await(async(e={})=>{const t=P({},await g(),e);return u(ge,t,"checkManager =>"),d(ge,t)})(e);let[n,a]=await L({code:t,service:!0});return a&&null===n&&await(async()=>{const e=await we.initManagerTemplate(),t=await(async(e={})=>{const t=P({},await g(),e);return u(le,t,"FlowManager =>"),d(le,t)})(),n=[oe(t)];await _({code:e,args:n,service:!0})})(),he()},be=async()=>{const e=await Me(),t=await(async(e={})=>{const t=P({},await g(),e);return u(pe,t,"getBlockOffset =>"),d(pe,t)})({FlowManager:e});return L({code:t})},Ae=async e=>{const t=await Me(),n=[e],a=await we.setBlockOffsetTemplate({FlowManager:t});return _({code:a,args:n,payer:[t]})},ye=async()=>{const e=await Me(),t=await(async(e={})=>{const t=P({},await g(),e);return u(me,t,"getTimestampOffset =>"),d(me,t)})({FlowManager:e});return L({code:t})},ke=async e=>{const t=await Me(),n=[e],a=await we.setTimestampOffsetTemplate({FlowManager:t});return _({code:a,args:n,payer:[t]})},Te=async(e,t=!1)=>{if(t){const t=Ee[e];if(void 0!==t)return t}const n=await Me(),a={FlowManager:n},r=await(async(e={})=>{const t=P({},await g(),e);return u(fe,t,"getContractAddress =>"),d(fe,t)})(a),s=[e,n],[o]=await L({code:r,args:s,service:!0});return o},xe=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,Fe=e=>e.split(/\s/).map(e=>e.replace(/\s/g,"")).filter(e=>e.length>0&&"import"!==e&&"from"!==e),Se=(e,t)=>{const[n,a]=t;return e[n]=a,e},ve=e=>e&&0!==e.length?e.split("\n").filter(e=>e.includes("import")).map(Fe).reduce(Se,{}):{},Pe=(e,t,n=!0)=>e.replace(xe,(e,a,r,s,o)=>{const c=n?r:o;return`${a}${r} from ${t instanceof Function?t(c):t[c]}`}),Be=async e=>{const t={},n=ve(e);for(const e in n)if(Ee[e])t[e]=Ee[e];else{const n=await Te(e);t[e]=n}return t},Ee={FlowToken:"0x0ae53cb6e3f42a79",FungibleToken:"0xee82856bf20e2aa6",FlowFees:"0xe5a8b7f23e8b548f",FlowStorageFees:"0xf8d6e0586b0a20c7"},Oe={"0xe5a8b7f23e8b548f":"0xe5a8b7f23e8b548f","0xf8d6e0586b0a20c7":"0xf8d6e0586b0a20c7","0x0ae53cb6e3f42a79":"0x0ae53cb6e3f42a79","0xee82856bf20e2aa6":"0xee82856bf20e2aa6"},Ce=async(e,n="transactions")=>{const r=await t().get("BASE_PATH");let s=r;if(R(r)){const t=r[n];if(t)return a.resolve(t,`./${e}.cdc`);s=r.base}return a.resolve(s,`./${n}/${e}.cdc`)},Ie=(e,t={},a=!1)=>{const r=(e=>n.readFileSync(e,"utf8"))(e);return t?Pe(r,P({},a?Oe:Ee,t)):r},Re=async({name:e,addressMap:t})=>{const n=await Ce(e,"contracts");return Ie(n,t)},Ue=async({name:e,addressMap:t})=>{const n=await Ce(e,"transactions");return Ie(n,t)},$e=async({name:e,addressMap:t})=>{const n=await Ce(e,"scripts");return Ie(n,t)},_e={ExampleToken:Ee.FlowToken},Le=e=>e[0].toLowerCase()+e.slice(1),De=async e=>{const t=await(async e=>(await(async(e={})=>{const t=P({},await g(),e);return u(de,t,"getBalance =>"),d(de,t)})(_e)).replace(/(ExampleToken)/gi,t=>"ExampleToken"===t?e:Le(e)))("FlowToken"),n=Pe(t,Ee);return L({code:n,args:[e]})},Ne=async(e,t)=>{const n=await(async e=>(await we.mintTokensTemplate(_e)).replace(/(ExampleToken)/gi,t=>"ExampleToken"===t?e:Le(e)))("FlowToken"),a=Pe(n,Ee);return _({code:a,args:[e,t]})},He=async e=>{const n=e||`deployment-account-${(Math.random()*Math.pow(10,8)).toFixed(0)}`,a=await Me(),r={FlowManager:a};let s;const o=await(async(e={})=>{const t=P({},await g(),e);return u(ue,t,"getAccountAddress =>"),d(ue,t)})(r),c=[n,a],[i]=await L({code:o,args:c,service:!0});if(s=i,null===s){const e=await we.createAccountTemplate(r),o=[n,await(async()=>{const e=O.keyFromPrivate(Buffer.from(await t().get("PRIVATE_KEY"),"hex")).getPublic("hex").replace(/^04/,"");return k.encode([Buffer.from(e,"hex"),2,3,1e3]).toString("hex")})(),a],[c]=await _({code:e,args:o}),{events:i}=c;s=i.find(e=>e.type.includes("AccountAdded")).data.address}return s},{expect:Ge}=global,Ke=async e=>"function"==typeof e?await e():await e,Ve=async e=>{const t=Ke(e),n=await t,[a,r]=n;if(r)throw r;let s,o;if(Array.isArray(a)){const{status:e,errorMessage:t}=a;s=e,o=t}else{const{status:e,errorMessage:t}=a;s=e,o=t}return await Ge(s).toBe(4),await Ge(o).toBe(""),n},ze=async e=>{const t=Ke(e),n=await t,[,a]=n;return Ge(a).toBe(null),n},je=async(e,t)=>{const n=Ke(e),a=await n,[r,s]=a;if(await Ge(r).toBe(null),t){var o;const e=null==(o=s.toString().match(/^error: (panic)|(assertion failed): ([^\r\n]*)$/m))?void 0:o.at(3);t instanceof RegExp?await Ge(e).toMatch(t):await Ge(e).toBe(t)}else await Ge(s).not.toBe(null);return a},Ye=async e=>{const t=Ke(e),n=await t,[a,r]=n;return await Ge(a).toBe(null),await Ge(r).not.toBe(null),n},Je=async e=>{let t=e;return((e,t)=>new RegExp("import\\s+FlowManager").test(t))(0,e)||(t=`\n      ${await(async()=>`import FlowManager from ${await he()}`)()}\n      ${e}  \n  `),t.replace(/getCurrentBlock\(\).height/g,"FlowManager.getBlockHeight()").replace(/getCurrentBlock\(\).timestamp/g,"FlowManager.getBlockTimestamp()")},{spawn:We}=require("child_process"),qe={log:console.log,service:console.log,info:console.log,error:console.error,warn:console.warn};var Qe=new class{constructor(){this.initialized=!1,this.logging=!1,this.filters=[],this.logProcessor=e=>e}setLogging(e){this.logging=e}log(e,t="log"){!1!==this.logging&&qe[t](e)}checkLevel(e,t){return"debug"===t&&e.includes("LOG")?"log":t}extractKeyValue(e){const[t,n]=e.split("=");return n.includes("LOG")?{key:t,value:n.replace('"[1;34m','"[1[34m')}:{key:t,value:n}}fixJSON(e){const t=e.split("\n").filter(e=>""!==e);return t.length>1?`[${t.join(",")}]`:t[0]}parseDataBuffer(e){const t=e.toString();try{if(t.includes("msg"))return JSON.parse(this.fixJSON(t))}catch(e){return console.error(e),{msg:e,level:"JSON Error"}}return{msg:t,level:"parser"}}async start(e={}){[this.grpcPort,this.restPort,this.adminPort]=await U(3),this.grpcPort=e.grpcPort||this.grpcPort,this.restPort=e.restPort||this.restPort,this.adminPort=e.adminPort||this.adminPort,(arguments.length>1||"number"==typeof arguments[0])&&(console.warn("Calling emulator.start with the port argument is now deprecated in favour of dynamically selected ports and will be removed in future versions of flow-js-testing.\nPlease refrain from supplying this argument, as using it may cause unintended consequences.\nMore info: https://github.com/onflow/flow-js-testing/blob/master/TRANSITIONS.md#001-deprecate-emulatorstart-port-argument"),[this.adminPort,e={}]=arguments,this.grpcPort=this.adminPort-8080+3569);const{flags:n="",logging:a=!1}=e;return t().put("accessNode.api",`http://localhost:${this.restPort}`),this.logging=a,this.process=We("flow",["emulator","--verbose","--log-format=JSON",`--rest-port=${this.restPort}`,`--admin-port=${this.adminPort}`,`--port=${this.grpcPort}`,n]),this.logProcessor=e=>e,await t().put("logger.level",0),new Promise((e,n)=>{let a;a=setInterval(async function(){try{await s(o([c(!1)])).then(i),clearInterval(a),await t().put("logger.level",2),this.initialized=!0,e(!0)}catch(e){}},100),this.process.stdout.on("data",e=>{const t=this.parseDataBuffer(e);if(Array.isArray(t)){let e=[];this.filters.length>0&&(e=t.filter(e=>{const t=this.checkLevel(e.msg,e.level);return this.filters.includes(t)}));for(let n=0;n<e.length;n++){const e=t[n],{msg:a}=e,r=this.checkLevel(a,e.level);this.log(`${r.toUpperCase()}: ${a}`)}}else{const{msg:e}=t,n=this.checkLevel(e,t.level);this.filters.length>0?this.filters.includes(n)&&(this.log(`${n.toUpperCase()}: ${e}`),e.includes("Starting")&&e.includes(this.adminPort)&&this.log("EMULATOR IS UP! Listening for events!")):(this.log(`${n.toUpperCase()}: ${e}`),t.msg.includes("Starting HTTP server")&&this.log("EMULATOR IS UP! Listening for events!"))}}),this.process.stderr.on("data",e=>{const{message:t}=this.parseDataBuffer(e);this.log(`EMULATOR ERROR: ${t}`,"error"),this.initialized=!1,clearInterval(a),n()}),this.process.on("close",t=>{this.filters.includes("service")&&this.log(`EMULATOR: process exited with code ${t}`),this.initialized=!1,clearInterval(a),e(!1)})})}clearFilters(){this.filters=[]}removeFilter(e){this.filters=this.filters.filter(t=>t!==e)}addFilter(e){this.filters.includes(e)||this.filters.push(e)}async stop(){return new Promise(e=>{this.process.kill(),setTimeout(()=>{this.initialized=!1,e(!1)},50)})}};export{Je as builtInMethods,ie as deployContract,ce as deployContractByName,Qe as emulator,L as executeScript,ve as extractImports,He as getAccountAddress,be as getBlockOffset,S as getConfigValue,Te as getContractAddress,Re as getContractCode,De as getFlowBalance,$e as getScriptCode,he as getServiceAddress,Ie as getTemplate,ye as getTimestampOffset,Ue as getTransactionCode,v as init,Ne as mintFlow,Ke as promise,Pe as replaceImportAddresses,Be as resolveImports,_ as sendTransaction,F as set,Ae as setBlockOffset,ke as setTimestampOffset,Ve as shallPass,ze as shallResolve,je as shallRevert,Ye as shallThrow};
//# sourceMappingURL=index.modern.js.map
